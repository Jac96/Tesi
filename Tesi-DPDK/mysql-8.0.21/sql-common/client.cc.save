/* Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License, version 2.0,
   as published by the Free Software Foundation.

   This program is also distributed with certain software (including
   but not limited to OpenSSL) that is licensed under separate terms,
   as designated in a particular file or component or in included license
   documentation.  The authors of MySQL hereby grant you an additional
   permission to link the program and your derivative works with the
   separately licensed software that they have included with MySQL.

   Without limiting anything contained in the foregoing, this file,
   which is part of C Driver for MySQL (Connector/C), is also subject to the
   Universal FOSS Exception, version 1.0, a copy of which can be found at
   http://oss.oracle.com/licenses/universal-foss-exception.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License, version 2.0, for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA */

/*
  This file is included by both libmysql.c (the MySQL client C API)
  and the mysqld server to connect to another MYSQL server.

  The differences for the two cases are:

  - Things that only works for the client:
  - Trying to automaticly determinate user name if not supplied to
    mysql_real_connect()
  - Support for reading local file with LOAD DATA LOCAL
  - SHARED memory handling
  - Prepared statements
  - Things that only works for the server

  In all other cases, the code should be idential for the client and
  server.
*/

#include "my_config.h"

#include <pthread.h>

static pthread_once_t client_is_initialized = PTHREAD_ONCE_INIT;

#include <stdarg.h>
#include <sys/types.h>

#include "m_ctype.h"
#include "m_string.h"
#include "my_sys.h"
#include "mysys_err.h"
#ifndef _WIN32
#include <netdb.h>
#endif
#ifdef HAVE_NETINET_IN_H
#include <netinet/in.h>
#endif
#include <stdio.h>
#include <string>

#include <algorithm>

#include "client_async_authentication.h"
#include "compression.h"  // validate_compression_attributes
#include "errmsg.h"
#include "lex_string.h"
#include "map_helpers.h"
#include "my_byteorder.h"
#include "my_compiler.h"
#include "my_dbug.h"
#include "my_default.h"
#include "my_inttypes.h"
#include "my_io.h"
#include "my_loglevel.h"
#include "my_macros.h"
#include "my_psi_config.h"
#include "my_shm_defaults.h"
#include "mysql.h"
#include "mysql/client_authentication.h"
#include "mysql/plugin_auth_common.h"
#include "mysql/psi/mysql_memory.h"
#include "mysql/service_mysql_alloc.h"
#include "mysql_version.h"
#include "mysqld_error.h"
#include "template_utils.h"
#include "typelib.h"
#include "violite.h"

#if !defined(_WIN32)
#include "my_thread.h" /* because of signal()	*/
#endif                 /* !defined(_WIN32) */

#include <signal.h>
#include <sys/stat.h>
#include <time.h>

#ifdef HAVE_PWD_H
#include <pwd.h>
#endif

#ifdef HAVE_SYS_SELECT_H
#include <sys/select.h>
#endif

#ifdef HAVE_SYS_UN_H
#include <sys/un.h>
#endif

#ifndef _WIN32
#include <errno.h>

#define SOCKET_ERROR -1
#endif

#include <openssl/x509v3.h>

#include <mysql/client_plugin.h>
#include <new>

#include "../libmysql/init_commands_array.h"
#include "../libmysql/mysql_trace.h" /* MYSQL_TRACE() instrumentation */
#include "sql_common.h"
#ifdef MYSQL_SERVER
#include "mysql_com_server.h"
#include "sql/client_settings.h"
#else
#include "libmysql/client_settings.h"
#endif
#include "client_extensions_macros.h"
#include "sql/log_event.h"     /* Log_event_type */
#include "sql/rpl_constants.h" /* mysql_binlog_XXX() */

using std::string;
using std::swap;

struct config client_conf = {};

#define STATE_DATA(M) \
  (NULL != (M) ? &(MYSQL_EXTENSION_PTR(M)->state_change) : NULL)

#define ADD_INFO(M, element, type)                       \
  {                                                      \
    M = STATE_DATA(mysql);                               \
    M->info_list[type].head_node =                       \
        list_add(M->info_list[type].head_node, element); \
  }

#define native_password_plugin_name "mysql_native_password"
#define caching_sha2_password_plugin_name "caching_sha2_password"

PSI_memory_key key_memory_mysql_options;
PSI_memory_key key_memory_MYSQL_DATA;
PSI_memory_key key_memory_MYSQL;
PSI_memory_key key_memory_MYSQL_RES;
PSI_memory_key key_memory_MYSQL_ROW;
PSI_memory_key key_memory_MYSQL_state_change_info;
PSI_memory_key key_memory_MYSQL_HANDSHAKE;

#if defined(_WIN32)
PSI_memory_key key_memory_create_shared_memory;
#endif /* _WIN32 */

#ifdef HAVE_PSI_INTERFACE
/*
  This code is common to the client and server,
  and also used in the server when server A connects to server B,
  for example with replication.
  Therefore, the code is also instrumented.
*/

static PSI_memory_info all_client_memory[] = {
#if defined(_WIN32)
    {&key_memory_create_shared_memory, "create_shared_memory", 0, 0,
     PSI_DOCUMENT_ME},
#endif /* _WIN32 */

    {&key_memory_mysql_options, "mysql_options", 0, 0, PSI_DOCUMENT_ME},
    {&key_memory_MYSQL_DATA, "MYSQL_DATA", 0, 0, PSI_DOCUMENT_ME},
    {&key_memory_MYSQL, "MYSQL", 0, 0, PSI_DOCUMENT_ME},
    {&key_memory_MYSQL_RES, "MYSQL_RES", 0, 0, PSI_DOCUMENT_ME},
    {&key_memory_MYSQL_ROW, "MYSQL_ROW", 0, 0, PSI_DOCUMENT_ME},
    {&key_memory_MYSQL_state_change_info, "MYSQL_STATE_CHANGE_INFO", 0, 0,
     PSI_DOCUMENT_ME},
    {&key_memory_MYSQL_HANDSHAKE, "MYSQL_HANDSHAKE", 0, 0, PSI_DOCUMENT_ME}};

void init_client_psi_keys(void) {
  const char *category = "client";
  int count;

  count = static_cast<int>(array_elements(all_client_memory));
  mysql_memory_register(category, all_client_memory, count);
}

#endif /* HAVE_PSI_INTERFACE */

uint mysql_port = 0;
char *mysql_unix_port = nullptr;
const char *unknown_sqlstate = "HY000";
const char *not_error_sqlstate = "00000";
const char *cant_connect_sqlstate = "08001";
#if defined(_WIN32)
static char *shared_memory_base_name = 0;
const char *def_shared_memory_base_name = default_shared_memory_base_name;
#endif

ulong g_net_buffer_length = 8192;
ulong g_max_allowed_packet = 1024L * 1024L * 1024L;

static void mysql_prune_stmt_list(MYSQL *mysql);
static int read_com_query_metadata(MYSQL *mysql, uchar *pos, ulong field_count);

CHARSET_INFO *default_client_charset_info = &my_charset_latin1;

/* Server error code and message */
unsigned int mysql_server_last_errno;
char mysql_server_last_error[MYSQL_ERRMSG_SIZE];
/* forward declaration */
static int read_one_row(MYSQL *mysql, uint fields, MYSQL_ROW row,
                        ulong *lengths);
static net_async_status read_one_row_nonblocking(MYSQL *mysql, uint fields,
                                                 MYSQL_ROW row, ulong *lengths,
                                                 int *res);

/**
  Convert the connect timeout option to a timeout value for VIO
  functions (vio_socket_connect() and vio_io_wait()).

  @param mysql  Connection handle (client side).

  @return The timeout value in milliseconds, or -1 if no timeout.
*/

static int get_vio_connect_timeout(MYSQL *mysql) {
  int timeout_ms;
  uint timeout_sec;

  /*
    A timeout of 0 means no timeout. Also, the connect_timeout
    option value is in seconds, while VIO timeouts are measured
    in milliseconds. Hence, check for a possible overflow. In
    case of overflow, set to no timeout.
  */
  timeout_sec = mysql->options.connect_timeout;

  if (!timeout_sec || (timeout_sec > INT_MAX / 1000))
    timeout_ms = -1;
  else
    timeout_ms = (int)(timeout_sec * 1000);

  return timeout_ms;
}

#ifdef _WIN32

/**
  Convert the connect timeout option to a timeout value for WIN32
  synchronization functions.

  @remark Specific for WIN32 connection methods shared memory and
          named pipe.

  @param mysql  Connection handle (client side).

  @return The timeout value in milliseconds, or INFINITE if no timeout.
*/

static DWORD get_win32_connect_timeout(MYSQL *mysql) {
  DWORD timeout_ms;
  uint timeout_sec;

  /*
    A timeout of 0 means no timeout. Also, the connect_timeout
    option value is in seconds, while WIN32 timeouts are in
    milliseconds. Hence, check for a possible overflow. In case
    of overflow, set to no timeout.
  */
  timeout_sec = mysql->options.connect_timeout;

  if (!timeout_sec || (timeout_sec > INT_MAX / 1000))
    timeout_ms = INFINITE;
  else
    timeout_ms = (DWORD)(timeout_sec * 1000);

  return timeout_ms;
}

#endif

/**
  Set the internal error message to mysql handler

  @param mysql    connection handle (client side)
  @param errcode  CR_ error code, passed to ER macro to get
                  error text
  @param sqlstate SQL standard sqlstate
*/

void set_mysql_error(MYSQL *mysql, int errcode, const char *sqlstate) {
  NET *net;
  DBUG_TRACE;
  DBUG_PRINT("enter", ("error :%d '%s'", errcode, ER_CLIENT(errcode)));
  DBUG_ASSERT(mysql != nullptr);

  if (mysql) {
    net = &mysql->net;
    net->last_errno = errcode;
    my_stpcpy(net->last_error, ER_CLIENT(errcode));
    my_stpcpy(net->sqlstate, sqlstate);
    MYSQL_TRACE(ERROR, mysql, ());
  } else {
    mysql_server_last_errno = errcode;
    my_stpcpy(mysql_server_last_error, ER_CLIENT(errcode));
  }
}

/**
  Is this NET instance initialized?
  @c my_net_init() and net_end()
 */

static bool my_net_is_inited(NET *net) { return net->buff != nullptr; }

/**
  Clear possible error state of struct NET

  @param net  clear the state of the argument
*/

void net_clear_error(NET *net) {
  net->last_errno = 0;
  net->last_error[0] = '\0';
  my_stpcpy(net->sqlstate, not_error_sqlstate);
}

/**
  Set an error message on the client.

  @param mysql     connection handle
  @param errcode   CR_* errcode, for client errors
  @param sqlstate  SQL standard sql state, unknown_sqlstate for the
                   majority of client errors.
  @param format    error message template, in sprintf format
  @param ...       variable number of arguments
*/

void set_mysql_extended_error(MYSQL *mysql, int errcode, const char *sqlstate,
                              const char *format, ...) {
  NET *net;
  va_list args;
  DBUG_TRACE;
  DBUG_PRINT("enter", ("error :%d '%s'", errcode, format));
  DBUG_ASSERT(mysql != nullptr);

  net = &mysql->net;
  net->last_errno = errcode;
  va_start(args, format);
  vsnprintf(net->last_error, sizeof(net->last_error) - 1, format, args);
  va_end(args);
  my_stpcpy(net->sqlstate, sqlstate);

  MYSQL_TRACE(ERROR, mysql, ());
}

/*
  Create a named pipe connection
*/

#ifdef _WIN32

static HANDLE create_named_pipe(MYSQL *mysql, DWORD connect_timeout,
                                const char **arg_host,
                                const char **arg_unix_socket) {
  HANDLE hPipe = INVALID_HANDLE_VALUE;
  char pipe_name[1024];
  DWORD dwMode;
  int i;
  bool testing_named_pipes = 0;
  const char *host = *arg_host, *unix_socket = *arg_unix_socket;

  if (!unix_socket || (unix_socket)[0] == 0x00) unix_socket = mysql_unix_port;
  if (!host || !strcmp(host, LOCAL_HOST)) host = LOCAL_HOST_NAMEDPIPE;

  pipe_name[sizeof(pipe_name) - 1] = 0; /* Safety if too long string */
  strxnmov(pipe_name, sizeof(pipe_name) - 1, "\\\\.\\pipe\\", unix_socket,
           NullS);

  DBUG_PRINT("info", ("Server name: '%s'.  Named Pipe: %s", host, unix_socket));

  for (i = 0; i < 100; i++) /* Don't retry forever */
  {
    if ((hPipe = CreateFile(pipe_name,
                            FILE_READ_ATTRIBUTES | FILE_READ_DATA |
                                FILE_WRITE_ATTRIBUTES | FILE_WRITE_DATA,
                            0, NULL, OPEN_EXISTING,
                            FILE_FLAG_OVERLAPPED | SECURITY_SQOS_PRESENT |
                                SECURITY_IDENTIFICATION,
                            NULL)) != INVALID_HANDLE_VALUE)
      break;
    if (GetLastError() != ERROR_PIPE_BUSY) {
      set_mysql_extended_error(mysql, CR_NAMEDPIPEOPEN_ERROR, unknown_sqlstate,
                               ER_CLIENT(CR_NAMEDPIPEOPEN_ERROR), host,
                               unix_socket, (ulong)GetLastError());
      return INVALID_HANDLE_VALUE;
    }
    /* wait for for an other instance */
    if (!WaitNamedPipe(pipe_name, connect_timeout)) {
      set_mysql_extended_error(mysql, CR_NAMEDPIPEWAIT_ERROR, unknown_sqlstate,
                               ER_CLIENT(CR_NAMEDPIPEWAIT_ERROR), host,
                               unix_socket, (ulong)GetLastError());
      return INVALID_HANDLE_VALUE;
    }
  }
  if (hPipe == INVALID_HANDLE_VALUE) {
    set_mysql_extended_error(mysql, CR_NAMEDPIPEOPEN_ERROR, unknown_sqlstate,
                             ER_CLIENT(CR_NAMEDPIPEOPEN_ERROR), host,
                             unix_socket, (ulong)GetLastError());
    return INVALID_HANDLE_VALUE;
  }
  dwMode = PIPE_READMODE_BYTE | PIPE_WAIT;
  if (!SetNamedPipeHandleState(hPipe, &dwMode, NULL, NULL)) {
    CloseHandle(hPipe);
    set_mysql_extended_error(mysql, CR_NAMEDPIPESETSTATE_ERROR,
                             unknown_sqlstate,
                             ER_CLIENT(CR_NAMEDPIPESETSTATE_ERROR), host,
                             unix_socket, (ulong)GetLastError());
    return INVALID_HANDLE_VALUE;
  }
  *arg_host = host;
  *arg_unix_socket = unix_socket; /* connect arg */
  return (hPipe);
}
#endif

/*
  Create new shared memory connection, return handler of connection

  @param mysql  Pointer of mysql structure
  @param net    Pointer of net structure
  @param connect_timeout  Timeout of connection (in milliseconds)

  @return HANDLE to the shared memory area.
*/

#if defined(_WIN32)
static HANDLE create_shared_memory(MYSQL *mysql, NET *net,
                                   DWORD connect_timeout) {
  ulong smem_buffer_length = shared_memory_buffer_length + 4;
  /*
    event_connect_request is event object for start connection actions
    event_connect_answer is event object for confirm, that server put data
    handle_connect_file_map is file-mapping object, use for create shared
    memory
    handle_connect_map is pointer on shared memory
    handle_map is pointer on shared memory for client
    event_server_wrote,
    event_server_read,
    event_client_wrote,
    event_client_read are events for transfer data between server and client
    handle_file_map is file-mapping object, use for create shared memory
  */
  HANDLE event_connect_request = NULL;
  HANDLE event_connect_answer = NULL;
  HANDLE handle_connect_file_map = NULL;
  char *handle_connect_map = NULL;

  char *handle_map = NULL;
  HANDLE event_server_wrote = NULL;
  HANDLE event_server_read = NULL;
  HANDLE event_client_wrote = NULL;
  HANDLE event_client_read = NULL;
  HANDLE event_conn_closed = NULL;
  HANDLE handle_file_map = NULL;
  HANDLE connect_named_mutex = NULL;
  ulong connect_number;
  char connect_number_char[22], *p;
  char *tmp = NULL;
  char *suffix_pos;
  DWORD error_allow = 0;
  DWORD error_code = 0;
  DWORD event_access_rights = SYNCHRONIZE | EVENT_MODIFY_STATE;
  char *shared_memory_base_name = mysql->options.shared_memory_base_name;
  static const char *name_prefixes[] = {"", "Global\\"};
  const char *prefix;
  int i;

  /*
    If this is NULL, somebody freed the MYSQL* options.  mysql_close()
    is a good candidate.  We don't just silently (re)set it to
    def_shared_memory_base_name as that would create really confusing/buggy
    behavior if the user passed in a different name on the command-line or
    in a my.cnf.
  */
  DBUG_ASSERT(shared_memory_base_name != NULL);

  /*
     get enough space base-name + '_' + longest suffix we might ever send
   */
  if (!(tmp = (char *)my_malloc(key_memory_create_shared_memory,
                                strlen(shared_memory_base_name) + 32L,
                                MYF(MY_FAE))))
    goto err;

  /*
    The name of event and file-mapping events create agree next rule:
    shared_memory_base_name+unique_part
    Where:
    shared_memory_base_name is unique value for each server
    unique_part is uniquel value for each object (events and file-mapping)
  */
  for (i = 0; i < array_elements(name_prefixes); i++) {
    prefix = name_prefixes[i];
    suffix_pos = strxmov(tmp, prefix, shared_memory_base_name, "_", NullS);
    my_stpcpy(suffix_pos, "CONNECT_REQUEST");
    event_connect_request = OpenEvent(event_access_rights, false, tmp);
    if (event_connect_request) {
      break;
    }
  }
  if (!event_connect_request) {
    error_allow = CR_SHARED_MEMORY_CONNECT_REQUEST_ERROR;
    goto err;
  }
  my_stpcpy(suffix_pos, "CONNECT_ANSWER");
  if (!(event_connect_answer = OpenEvent(event_access_rights, false, tmp))) {
    error_allow = CR_SHARED_MEMORY_CONNECT_ANSWER_ERROR;
    goto err;
  }
  my_stpcpy(suffix_pos, "CONNECT_DATA");
  if (!(handle_connect_file_map =
            OpenFileMapping(FILE_MAP_WRITE, false, tmp))) {
    error_allow = CR_SHARED_MEMORY_CONNECT_FILE_MAP_ERROR;
    goto err;
  }
  if (!(handle_connect_map = static_cast<char *>(MapViewOfFile(
            handle_connect_file_map, FILE_MAP_WRITE, 0, 0, sizeof(DWORD))))) {
    error_allow = CR_SHARED_MEMORY_CONNECT_MAP_ERROR;
    goto err;
  }

  my_stpcpy(suffix_pos, "CONNECT_NAMED_MUTEX");
  connect_named_mutex = OpenMutex(SYNCHRONIZE, false, tmp);
  if (connect_named_mutex == NULL) {
    error_allow = CR_SHARED_MEMORY_CONNECT_SET_ERROR;
    goto err;
  }

  if (WaitForSingleObject(connect_named_mutex, connect_timeout) !=
      WAIT_OBJECT_0) {
    error_allow = CR_SHARED_MEMORY_CONNECT_ABANDONED_ERROR;
    goto err;
  }

  /* Send to server request of connection */
  if (!SetEvent(event_connect_request)) {
    error_allow = CR_SHARED_MEMORY_CONNECT_SET_ERROR;
    goto err;
  }

  /* Wait of answer from server */
  if (WaitForSingleObject(event_connect_answer, connect_timeout) !=
      WAIT_OBJECT_0) {
    error_allow = CR_SHARED_MEMORY_CONNECT_ABANDONED_ERROR;
    goto err;
  }

  /* Get number of connection */
  connect_number = uint4korr(handle_connect_map); /*WAX2*/

  ReleaseMutex(connect_named_mutex);
  CloseHandle(connect_named_mutex);
  connect_named_mutex = NULL;

  p = longlong10_to_str(connect_number, connect_number_char, 10);

  /*
    The name of event and file-mapping events create agree next rule:
    shared_memory_base_name+unique_part+number_of_connection

    Where:
    shared_memory_base_name is uniquel value for each server
    unique_part is uniquel value for each object (events and file-mapping)
    number_of_connection is number of connection between server and client
  */
  suffix_pos = strxmov(tmp, prefix, shared_memory_base_name, "_",
                       connect_number_char, "_", NullS);
  my_stpcpy(suffix_pos, "DATA");
  if ((handle_file_map = OpenFileMapping(FILE_MAP_WRITE, false, tmp)) == NULL) {
    error_allow = CR_SHARED_MEMORY_FILE_MAP_ERROR;
    goto err2;
  }
  if ((handle_map = static_cast<char *>(MapViewOfFile(
           handle_file_map, FILE_MAP_WRITE, 0, 0, smem_buffer_length))) ==
      NULL) {
    error_allow = CR_SHARED_MEMORY_MAP_ERROR;
    goto err2;
  }

  my_stpcpy(suffix_pos, "SERVER_WROTE");
  if ((event_server_wrote = OpenEvent(event_access_rights, false, tmp)) ==
      NULL) {
    error_allow = CR_SHARED_MEMORY_EVENT_ERROR;
    goto err2;
  }

  my_stpcpy(suffix_pos, "SERVER_READ");
  if ((event_server_read = OpenEvent(event_access_rights, false, tmp)) ==
      NULL) {
    error_allow = CR_SHARED_MEMORY_EVENT_ERROR;
    goto err2;
  }

  my_stpcpy(suffix_pos, "CLIENT_WROTE");
  if ((event_client_wrote = OpenEvent(event_access_rights, false, tmp)) ==
      NULL) {
    error_allow = CR_SHARED_MEMORY_EVENT_ERROR;
    goto err2;
  }

  my_stpcpy(suffix_pos, "CLIENT_READ");
  if ((event_client_read = OpenEvent(event_access_rights, false, tmp)) ==
      NULL) {
    error_allow = CR_SHARED_MEMORY_EVENT_ERROR;
    goto err2;
  }

  my_stpcpy(suffix_pos, "CONNECTION_CLOSED");
  if ((event_conn_closed = OpenEvent(event_access_rights, false, tmp)) ==
      NULL) {
    error_allow = CR_SHARED_MEMORY_EVENT_ERROR;
    goto err2;
  }
  /*
    Set event that server should send data
  */
  SetEvent(event_server_read);

err2:
  if (error_allow == 0) {
    net->vio = vio_new_win32shared_memory(
        handle_file_map, handle_map, event_server_wrote, event_server_read,
        event_client_wrote, event_client_read, event_conn_closed);
  } else {
    error_code = GetLastError();
    if (event_server_read) CloseHandle(event_server_read);
    if (event_server_wrote) CloseHandle(event_server_wrote);
    if (event_client_read) CloseHandle(event_client_read);
    if (event_client_wrote) CloseHandle(event_client_wrote);
    if (event_conn_closed) CloseHandle(event_conn_closed);
    if (handle_map) UnmapViewOfFile(handle_map);
    if (handle_file_map) CloseHandle(handle_file_map);
  }
err:
  my_free(tmp);
  if (error_allow) error_code = GetLastError();
  if (event_connect_request) CloseHandle(event_connect_request);
  if (event_connect_answer) CloseHandle(event_connect_answer);
  if (handle_connect_map) UnmapViewOfFile(handle_connect_map);
  if (handle_connect_file_map) CloseHandle(handle_connect_file_map);
  if (error_allow) {
    if (connect_named_mutex) {
      ReleaseMutex(connect_named_mutex);
      CloseHandle(connect_named_mutex);
    }

    if (error_allow == CR_SHARED_MEMORY_EVENT_ERROR)
      set_mysql_extended_error(mysql, error_allow, unknown_sqlstate,
                               ER_CLIENT(error_allow), suffix_pos, error_code);
    else
      set_mysql_extended_error(mysql, error_allow, unknown_sqlstate,
                               ER_CLIENT(error_allow), error_code);
    return (INVALID_HANDLE_VALUE);
  }
  return (handle_map);
}
#endif

/*
  Free all memory acquired to store state change information.
*/
static void free_state_change_info(MYSQL_EXTENSION *ext) {
  STATE_INFO *info;
  int i;

  if (ext)
    info = &ext->state_change;
  else
    return;

  for (i = SESSION_TRACK_SYSTEM_VARIABLES; i <= SESSION_TRACK_END; i++) {
    if (list_length(info->info_list[i].head_node) != 0) {
      list_free(info->info_list[i].head_node, (uint)0);
    }
  }
  memset(info, 0, sizeof(STATE_INFO));
}

/**
  Helper function to check if the buffer has at least bytes remaining

  If the buffer is too small it raises CR_MALFORMED_PACKET_ERROR.

  @param mysql the handle that has the buffer
  @param packet the current position in the buffer
  @param packet_length the size of the packet
  @param bytes the bytes that we want available
  @retval true the buffer has that many bytes
  @retval false the buffer has less bytes remaining
*/
inline bool buffer_check_remaining(MYSQL *mysql, uchar *packet,
                                   ulong packet_length, size_t bytes) {
  size_t remaining_bytes = packet_length - (packet - mysql->net.read_pos);
  if (remaining_bytes < bytes) {
    set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
    return false;
  }
  return true;
}

/*
  Helper function to safely read a variable size from a buffer.
  If the buffer is too small it raises CR_MALFORMED_PACKET_ERROR
  and sets is_error to true.
  Otherwise it sets is_error to false and calls @ref inet_field_length_ll.

  @sa @ref net_field_length_ll

  @param mysql the handle to return an error in
  @param [in,out] packet pointer to the buffer to read the length from
  @param packet_length  remining bytes in packet
  @param [out] is_error set to true if the buffer contains no room for a
  full length, false otherwise.
  @return the size read.
*/
inline my_ulonglong net_field_length_ll_safe(MYSQL *mysql, uchar **packet,
                                             ulong packet_length,
                                             bool *is_error) {
  size_t sizeof_len = net_field_length_size(*packet);
  if (!buffer_check_remaining(mysql, *packet, packet_length, sizeof_len)) {
    *is_error = true;
    return 0;
  }

  *is_error = false;
  return net_field_length_ll(packet);
}

/**
 Read Ok packet along with the server state change information.
*/
void read_ok_ex(MYSQL *mysql, ulong length) {
  size_t total_len, len;
  uchar *pos, *saved_pos;
  my_ulonglong affected_rows, insert_id;
  char *db;
  char *data_str;

  CHARSET_INFO *saved_cs;
  bool is_charset;

  STATE_INFO *info = nullptr;
  enum enum_session_state_type type;
  LIST *element = nullptr;
  LEX_STRING *data = nullptr;
  bool is_error;

  pos = mysql->net.read_pos + 1;

  affected_rows = net_field_length_ll_safe(mysql, &pos, length,
                                           &is_error); /* affected rows */
  if (is_error) return;
  insert_id =
      net_field_length_ll_safe(mysql, &pos, length, &is_error); /* insert id */
  if (is_error) return;

  /*
   The following check ensures that we skip the assignment for the
   above read fields (i.e. affected_rows and insert_id) wherein the
   EOF packets are deprecated and the server sends OK packet instead
   with a packet header of 0xFE (254) to identify it as an EOF packet.
   We ignore this assignment as the valid contents of EOF packet include
   packet marker, server status and warning count only. However, we would
   assign these values to the connection handle if it was an OK packet
   with a packet header of 0x00.
  */

  if (!((mysql->server_capabilities & CLIENT_DEPRECATE_EOF) &&
        mysql->net.read_pos[0] == 254)) {
    mysql->affected_rows = affected_rows;
    mysql->insert_id = insert_id;

    DBUG_PRINT("info", ("affected_rows: %lu  insert_id: %lu",
                        (ulong)mysql->affected_rows, (ulong)mysql->insert_id));
  }

  if (!buffer_check_remaining(mysql, pos, length, 2)) return;
  /* server status */
  mysql->server_status = uint2korr(pos);
  pos += 2;

  if (protocol_41(mysql)) {
    if (!buffer_check_remaining(mysql, pos, length, 2)) return;
    mysql->warning_count = uint2korr(pos);
    pos += 2;
  } else
    mysql->warning_count = 0; /* MySQL 4.0 protocol */

  DBUG_PRINT("info", ("status: %u  warning_count: %u", mysql->server_status,
                      mysql->warning_count));
  if (mysql->server_capabilities & CLIENT_SESSION_TRACK) {
    free_state_change_info(static_cast<MYSQL_EXTENSION *>(mysql->extension));

    if (pos < mysql->net.read_pos + length) {
      /* get the info field */
      size_t length_msg_member =
          (size_t)net_field_length_ll_safe(mysql, &pos, length, &is_error);
      if (is_error) return;
      if (!buffer_check_remaining(mysql, pos, length, length_msg_member))
        return;
      mysql->info = (length_msg_member ? (char *)pos : nullptr);
      pos += (length_msg_member);

      /* read session state changes info */
      if (mysql->server_status & SERVER_SESSION_STATE_CHANGED) {
        saved_pos = pos;
        total_len =
            (size_t)net_field_length_ll_safe(mysql, &pos, length, &is_error);
        if (is_error) return;
        /* ensure that mysql->info is zero-terminated */
        if (mysql->info) *saved_pos = 0;

        while (total_len > 0) {
          saved_pos = pos;
          type = (enum enum_session_state_type)net_field_length_ll_safe(
              mysql, &pos, length, &is_error);
          if (is_error) return;
          switch (type) {
            case SESSION_TRACK_SYSTEM_VARIABLES:
              /* Move past the total length of the changed entity. */
              (void)net_field_length_ll_safe(mysql, &pos, length, &is_error);
              if (is_error) return;

              /* Name of the system variable. */
              len = (size_t)net_field_length_ll_safe(mysql, &pos, length,
                                                     &is_error);
              if (is_error) return;
              if (!buffer_check_remaining(mysql, pos, length, len)) return;

              if (!my_multi_malloc(key_memory_MYSQL_state_change_info, MYF(0),
                                   &element, sizeof(LIST), &data,
                                   sizeof(LEX_STRING), &data_str, len, NullS)) {
                set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
                return;
              }

              data->str = data_str;
              memcpy(data->str, (char *)pos, len);
              data->length = len;
              pos += len;

              element->data = data;
              ADD_INFO(info, element, SESSION_TRACK_SYSTEM_VARIABLES);

              /*
               Check if the changed variable was charset. In that case we need
               to update mysql->charset.
               */
              if (!strncmp(data->str, "character_set_client", data->length))
                is_charset = true;
              else
                is_charset = false;

              /* Value of the system variable. */
              len = (size_t)net_field_length_ll_safe(mysql, &pos, length,
                                                     &is_error);
              if (is_error) return;
              if (!buffer_check_remaining(mysql, pos, length, len)) return;

              if (!my_multi_malloc(key_memory_MYSQL_state_change_info, MYF(0),
                                   &element, sizeof(LIST), &data,
                                   sizeof(LEX_STRING), &data_str, len, NullS)) {
                set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
                return;
              }

              data->str = data_str;
              memcpy(data->str, (char *)pos, len);
              data->length = len;
              pos += len;

              element->data = data;
              ADD_INFO(info, element, SESSION_TRACK_SYSTEM_VARIABLES);

              if (is_charset == 1) {
                char charset_name[MY_CS_NAME_SIZE * 8];  // MY_CS_BUFFER_SIZE
                size_t charset_name_length =
                    std::min(data->length, sizeof(charset_name) - 1);
                saved_cs = mysql->charset;

                memcpy(charset_name, data->str, charset_name_length);
                charset_name[charset_name_length] = 0;

                if (!(mysql->charset = get_charset_by_csname(
                          charset_name, MY_CS_PRIMARY, MYF(MY_WME)))) {
                  DBUG_PRINT(
                      "warning",
                      ("session tracker supplied %s is not a valid charset."
                       " Keeping the old one.",
                       charset_name));
                  mysql->charset = saved_cs;
                }
              }
              break;
            case SESSION_TRACK_TRANSACTION_STATE:
            case SESSION_TRACK_TRANSACTION_CHARACTERISTICS:
            case SESSION_TRACK_SCHEMA:

              /* Move past the total length of the changed entity. */
              (void)net_field_length_ll_safe(mysql, &pos, length, &is_error);
              if (is_error) return;
              len = (size_t)net_field_length_ll_safe(mysql, &pos, length,
                                                     &is_error);
              if (is_error) return;
              if (!buffer_check_remaining(mysql, pos, length, len)) return;

              if (!my_multi_malloc(key_memory_MYSQL_state_change_info, MYF(0),
                                   &element, sizeof(LIST), &data,
                                   sizeof(LEX_STRING), &data_str, len, NullS)) {
                set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
                return;
              }

              data->str = data_str;
              memcpy(data->str, (char *)pos, len);
              data->length = len;
              pos += len;

              element->data = data;
              ADD_INFO(info, element, type);

              if (type == SESSION_TRACK_SCHEMA) {
                if (!(db = (char *)my_malloc(key_memory_MYSQL_state_change_info,
                                             data->length + 1, MYF(MY_WME)))) {
                  set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
                  return;
                }

                if (mysql->db) my_free(mysql->db);

                memcpy(db, data->str, data->length);
                db[data->length] = '\0';
                mysql->db = db;
              }

              break;
            case SESSION_TRACK_GTIDS:
              /* Move past the total length of the changed entity. */
              (void)net_field_length_ll_safe(mysql, &pos, length, &is_error);
              if (is_error) return;

              /* read (and ignore for now) the GTIDS encoding specification code
               */
              (void)net_field_length_ll_safe(mysql, &pos, length, &is_error);
              if (is_error) return;

              /*
                 For now we ignore the encoding specification, since only one
                 is supported. In the future the decoding of what comes next
                 depends on the specification code.
                 */

              /* read the length of the encoded string. */
              len = (size_t)net_field_length_ll_safe(mysql, &pos, length,
                                                     &is_error);
              if (is_error) return;
              if (!buffer_check_remaining(mysql, pos, length, len)) return;

              if (!my_multi_malloc(key_memory_MYSQL_state_change_info, MYF(0),
                                   &element, sizeof(LIST), &data,
                                   sizeof(LEX_STRING), &data_str, len, NullS)) {
                set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
                return;
              }

              data->str = data_str;
              memcpy(data->str, (char *)pos, len);
              data->length = len;
              pos += len;

              element->data = data;
              ADD_INFO(info, element, SESSION_TRACK_GTIDS);
              break;
            case SESSION_TRACK_STATE_CHANGE:
              /* Get the length of the boolean tracker */
              len = (size_t)net_field_length_ll_safe(mysql, &pos, length,
                                                     &is_error);
              if (is_error) return;

              /* length for boolean tracker is always 1 */
              DBUG_ASSERT(len == 1);
              if (!buffer_check_remaining(mysql, pos, length, len)) return;

              if (!my_multi_malloc(key_memory_MYSQL_state_change_info, MYF(0),
                                   &element, sizeof(LIST), &data,
                                   sizeof(LEX_STRING), &data_str, len, NullS)) {
                set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
                return;
              }

              data->str = data_str;
              memcpy(data->str, (char *)pos, len);
              data->length = len;
              pos += len;

              element->data = data;
              ADD_INFO(info, element, SESSION_TRACK_STATE_CHANGE);

              break;
            default:
              DBUG_ASSERT(type <= SESSION_TRACK_END);
              /*
               Unknown/unsupported type received, get the total length and move
               past it.
               */

              len = (size_t)net_field_length_ll_safe(mysql, &pos, length,
                                                     &is_error);
              if (is_error) return;
              pos += len;
              break;
          }
          total_len -= (pos - saved_pos);
        }
        if (info) {
          int itype;
          for (itype = SESSION_TRACK_BEGIN; itype < SESSION_TRACK_END;
               itype++) {
            if (info->info_list[itype].head_node) {
              info->info_list[itype].current_node =
                  info->info_list[itype].head_node =
                      list_reverse(info->info_list[itype].head_node);
            }
          }
        }
      }
    }
  } else if (pos < mysql->net.read_pos + length && net_field_length(&pos))
    mysql->info = (char *)pos;
  else
    mysql->info = nullptr;
  return;
}

/* Helper for cli_safe_read and cli_safe_read_nonblocking */
static ulong cli_safe_read_with_ok_complete(MYSQL *mysql, bool parse_ok,
                                            bool *is_data_packet, ulong len);

/**
  Read a packet from server in asynchronous way. This function can return
  without completly reading the packet, in such a case call this function
  again until complete packet is read.

  @param[in]  mysql           connection handle
  @param[in]  parse_ok	      if set to true then parse OK packet if it
                              was sent by server
  @param[out] is_data_packet  if set to true then the packet received
                              was a "data packet".
  @param[out] res             The length of the packet that was read or
                              packet_error in case of error.

  @retval     NET_ASYNC_NOT_READY  packet was not completely read
  @retval     NET_ASYNC_COMPLETE   finished reading packet
*/
net_async_status cli_safe_read_with_ok_nonblocking(MYSQL *mysql, bool parse_ok,
                                                   bool *is_data_packet,
                                                   ulong *res) {
  NET *net = &mysql->net;
  ulong len = 0;
  DBUG_TRACE;
  DBUG_ASSERT(net->vio);

  if (NET_ASYNC_NOT_READY == my_net_read_nonblocking(net, &len)) {
    return NET_ASYNC_NOT_READY;
  }

  DBUG_PRINT("info",
             ("total nb read: %lu,  net->where_b: %lu", len, net->where_b));

  *res = cli_safe_read_with_ok_complete(mysql, parse_ok, is_data_packet, len);

  /*
    In case, packet is too large or connection is lost, net_end() is called to
    free up net->extention. Thus return NET_ASYNC_ERROR.
  */
  if ((*res == packet_error) && (NET_ASYNC_DATA(net) == nullptr)) {
    return NET_ASYNC_ERROR;
  }
  return NET_ASYNC_COMPLETE;
}

/**
  Its a non blocking version of cli_safe_read
*/
net_async_status cli_safe_read_nonblocking(MYSQL *mysql, bool *is_data_packet,
                                           ulong *res) {
  return cli_safe_read_with_ok_nonblocking(mysql, false, is_data_packet, res);
}

/**
  Read a packet from server. Give error message if socket was down
  or packet is an error message

  @param[in]    mysql           connection handle
  @param[in]    parse_ok        if set to true then parse OK packet
                                if it is received
  @param[out]   is_data_packet
                                if set to true then packet received is
                                a "data packet", that is not OK or ERR
                                packet or EOF in case of old servers

  @return  The length of the packet that was read or packet_error in
           case of error. In case of error its description is stored
            in mysql handle.
*/

ulong cli_safe_read_with_ok(MYSQL *mysql, bool parse_ok, bool *is_data_packet) {
  NET *net = &mysql->net;
  ulong len = 0;

  MYSQL_TRACE(READ_PACKET, mysql, ());

  if (is_data_packet) *is_data_packet = false;

  if (net->vio != nullptr) len = my_net_read(net);
  return cli_safe_read_with_ok_complete(mysql, parse_ok, is_data_packet, len);
}

ulong cli_safe_read_with_ok_complete(MYSQL *mysql, bool parse_ok,
                                     bool *is_data_packet, ulong len) {
  NET *net = &mysql->net;
  DBUG_TRACE;

  if (len == packet_error || len == 0) {
#ifndef DBUG_OFF
    char desc[VIO_DESCRIPTION_SIZE];
    vio_description(net->vio, desc);
    DBUG_PRINT("error",
               ("Wrong connection or packet. fd: %s  len: %lu", desc, len));
#endif  // DBUG_OFF
#ifdef MYSQL_SERVER
    if (net->vio && (net->last_errno == ER_NET_READ_INTERRUPTED))
      return packet_error;
#endif /*MYSQL_SERVER*/
    end_server(mysql);
    set_mysql_error(mysql,
                    net->last_errno == ER_NET_PACKET_TOO_LARGE
                        ? CR_NET_PACKET_TOO_LARGE
                        : CR_SERVER_LOST,
                    unknown_sqlstate);
    return packet_error;
  }

  MYSQL_TRACE(PACKET_RECEIVED, mysql, (len, net->read_pos));

  if (net->read_pos[0] == 255) {
    /*
      After server reprts an error, usually it is ready to accept new commands
      and we set stage to READY_FOR_COMMAND. This can be modified by the caller
      of cli_safe_read().
    */
    MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);

    if (len > 3) {
      uchar *pos = net->read_pos + 1;
      net->last_errno = uint2korr(pos);
      pos += 2;
      len -= 2;
      if (protocol_41(mysql) && pos[0] == '#') {
        strmake(net->sqlstate, (char *)pos + 1, SQLSTATE_LENGTH);
        pos += SQLSTATE_LENGTH + 1;
      } else {
        /*
          The SQL state hasn't been received -- it should be reset to HY000
          (unknown error sql state).
        */

        my_stpcpy(net->sqlstate, unknown_sqlstate);
      }

      (void)strmake(net->last_error, (char *)pos,
                    std::min<ulong>(len, sizeof(net->last_error) - 1));
    } else
      set_mysql_error(mysql, CR_UNKNOWN_ERROR, unknown_sqlstate);
    /*
      Cover a protocol design error: error packet does not
      contain the server status. Therefore, the client has no way
      to find out whether there are more result sets of
      a multiple-result-set statement pending. Luckily, in 5.0 an
      error always aborts execution of a statement, wherever it is
      a multi-statement or a stored procedure, so it should be
      safe to unconditionally turn off the flag here.
    */
    mysql->server_status &= ~SERVER_MORE_RESULTS_EXISTS;

    DBUG_PRINT("error", ("Got error: %d/%s (%s)", net->last_errno,
                         net->sqlstate, net->last_error));
    return packet_error;
  } else {
    /* if it is OK packet irrespective of new/old server */
    if (net->read_pos[0] == 0) {
      if (parse_ok) {
        read_ok_ex(mysql, len);
        return len;
      }
    }
    /*
      Now we have a data packet, unless it is OK packet starting with
      0xFE - we detect that case below.
    */
    if (is_data_packet) *is_data_packet = true;
    /*
       For a packet starting with 0xFE detect if it is OK packet or a
       huge data packet. Note that old servers do not send OK packets
       starting with 0xFE.
    */
    if ((mysql->server_capabilities & CLIENT_DEPRECATE_EOF) &&
        (net->read_pos[0] == 254)) {
      /* detect huge data packet */
      if (len > MAX_PACKET_LENGTH) return len;
      /* otherwise we have OK packet starting with 0xFE */
      if (is_data_packet) *is_data_packet = false;
      /* parse it if requested */
      if (parse_ok) read_ok_ex(mysql, len);
      return len;
    }
    /* for old client detect EOF packet */
    if (!(mysql->server_capabilities & CLIENT_DEPRECATE_EOF) &&
        (net->read_pos[0] == 254) && (len < 8)) {
      if (is_data_packet) *is_data_packet = false;
    }
  }
  return len;
}

/**
  Read a packet from server. Give error message if connection was broken or
  ERR packet was received. Detect if the packet received was an OK, ERR or
  something else (a "data packet").

  @param[in]  mysql           connection handle
  @param[out] is_data_packet
                              if set to true then the packet received
                              was a "data packet".

  @retval The length of the packet that was read or packet_error in case of
          error. In case of error its description is stored in mysql handle.
*/
ulong cli_safe_read(MYSQL *mysql, bool *is_data_packet) {
  return cli_safe_read_with_ok(mysql, false, is_data_packet);
}

void free_rows(MYSQL_DATA *cur) {
  if (cur) {
    free_root(cur->alloc, MYF(0));
    my_free(cur->alloc);
    my_free(cur);
  }
}

bool cli_advanced_command(MYSQL *mysql, enum enum_server_command command,
                          const uchar *header, size_t header_length,
                          const uchar *arg, size_t arg_length, bool skip_check,
                          MYSQL_STMT *stmt) {
  NET *net = &mysql->net;
  bool result = true;
  bool stmt_skip = stmt ? stmt->state != MYSQL_STMT_INIT_DONE : false;
  DBUG_TRACE;

  if (mysql->net.vio == nullptr) { /* Do reconnect if possible */
    if (mysql_reconnect(mysql) || stmt_skip) return true;
  }
  /* turn off non blocking operations */
  if (!vio_is_blocking(mysql->net.vio))
    vio_set_blocking_flag(mysql->net.vio, true);

  if (mysql->status != MYSQL_STATUS_READY ||
      mysql->server_status & SERVER_MORE_RESULTS_EXISTS) {
    DBUG_PRINT("error", ("state: %d", mysql->status));
    set_mysql_error(mysql, CR_COMMANDS_OUT_OF_SYNC, unknown_sqlstate);
    return true;
  }

  net_clear_error(net);
  mysql->info = nullptr;
  mysql->affected_rows = ~(my_ulonglong)0;
  /*
    Do not check the socket/protocol buffer on COM_QUIT as the
    result of a previous command might not have been read. This
    can happen if a client sends a query but does not reap the
    result before attempting to close the connection.
  */
  net_clear(&mysql->net, (command != COM_QUIT));

  MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);
  MYSQL_TRACE(SEND_COMMAND, mysql,
              (command, header_length, arg_length, header, arg));

  /*
    If auto-reconnect mode is enabled check if connection is still alive before
    sending new command. Otherwise, send() might not notice that connection was
    closed by the server (for example, due to KILL statement), and the fact that
    connection is gone will be noticed only on attempt to read command's result,
    when it is too late to reconnect. Note that such scenario can still occur if
    connection gets killed after this check but before command is sent to
    server. But this should be rare.
  */
  if ((command != COM_QUIT) && mysql->reconnect && !vio_is_connected(net->vio))
    net->error = 2;

  if (net_write_command(net, (uchar)command, header, header_length, arg,
                        arg_length)) {
    DBUG_PRINT("error",
               ("Can't send command to server. Error: %d", socket_errno));
    if (net->last_errno == ER_NET_PACKET_TOO_LARGE) {
      set_mysql_error(mysql, CR_NET_PACKET_TOO_LARGE, unknown_sqlstate);
      goto end;
    }
    end_server(mysql);

    if (mysql_reconnect(mysql) || stmt_skip) goto end;

    MYSQL_TRACE(SEND_COMMAND, mysql,
                (command, header_length, arg_length, header, arg));
    if (net_write_command(net, (uchar)command, header, header_length, arg,
                          arg_length)) {
      set_mysql_error(mysql, CR_SERVER_GONE_ERROR, unknown_sqlstate);
      goto end;
    }
  }

  MYSQL_TRACE(PACKET_SENT, mysql, (header_length + arg_length));

#if defined(CLIENT_PROTOCOL_TRACING)
  switch (command) {
    case COM_STMT_PREPARE:
      MYSQL_TRACE_STAGE(mysql, WAIT_FOR_PS_DESCRIPTION);
      break;

    case COM_STMT_FETCH:
      MYSQL_TRACE_STAGE(mysql, WAIT_FOR_ROW);
      break;

    /*
      No server reply is expected after these commands so we reamin ready
      for the next command.
   */
    case COM_STMT_SEND_LONG_DATA:
    case COM_STMT_CLOSE:
    case COM_REGISTER_SLAVE:
    case COM_QUIT:
      break;

    /*
      These replication commands are not supported and we bail out
      by pretending that connection has been closed.
    */
    case COM_BINLOG_DUMP:
    case COM_BINLOG_DUMP_GTID:
    case COM_TABLE_DUMP:
      MYSQL_TRACE(DISCONNECTED, mysql, ());
      break;

    /*
      After COM_CHANGE_USER a regular authentication exchange
      is performed.
    */
    case COM_CHANGE_USER:
      MYSQL_TRACE_STAGE(mysql, AUTHENTICATE);
      break;

    /*
      Server replies to COM_STATISTICS with a single packet
      containing a string with statistics information.
    */
    case COM_STATISTICS:
      MYSQL_TRACE_STAGE(mysql, WAIT_FOR_PACKET);
      break;

    /*
      For all other commands we expect server to send regular reply which
      is either OK, ERR or a result-set header.
    */
    default:
      MYSQL_TRACE_STAGE(mysql, WAIT_FOR_RESULT);
      break;
  }
#endif

  result = false;
  if (!skip_check) {
    result = ((mysql->packet_length =
                   cli_safe_read_with_ok(mysql, true, nullptr)) == packet_error
                  ? 1
                  : 0);

#if defined(CLIENT_PROTOCOL_TRACING)
    /*
      Return to READY_FOR_COMMAND protocol stage in case server reports error
      or sends OK packet.
    */
    if (result || mysql->net.read_pos[0] == 0x00)
      MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);
#endif
  }

end:
  DBUG_PRINT("exit", ("result: %d", result));
  return result;
}

net_async_status cli_advanced_command_nonblocking(
    MYSQL *mysql, enum enum_server_command command, const uchar *header,
    ulong header_length, const uchar *arg, ulong arg_length, bool skip_check,
    MYSQL_STMT *stmt, bool *ret) {
  NET *net = &mysql->net;
  NET_ASYNC *net_async = NET_ASYNC_DATA(net);
  bool result = true;
  *ret = result;
  bool stmt_skip = stmt ? stmt->state != MYSQL_STMT_INIT_DONE : false;
  DBUG_TRACE;
  DBUG_DUMP("sending", header, header_length);
  if (arg && arg_length) {
    DBUG_DUMP("sending arg", arg, arg_length);
  }

  if (mysql->net.vio == nullptr) {
    set_mysql_error(mysql, CR_SERVER_GONE_ERROR, unknown_sqlstate);
    goto end;
  }
  /**
    When non blocking API execution is pending and did not complete then
    it can result in async context to be null. In such case if user executes
    any other API report command out of sync error.
  */
  if (net_async == nullptr) {
    set_mysql_error(mysql, CR_COMMANDS_OUT_OF_SYNC, unknown_sqlstate);
    goto end;
  }
  if (net_async->async_send_command_status == NET_ASYNC_SEND_COMMAND_IDLE) {
    if (vio_is_blocking(mysql->net.vio)) {
      vio_set_blocking_flag(net->vio, false);
    }

    if (mysql->status != MYSQL_STATUS_READY ||
        mysql->server_status & SERVER_MORE_RESULTS_EXISTS) {
      DBUG_PRINT("error", ("state: %d", mysql->status));
      set_mysql_error(mysql, CR_COMMANDS_OUT_OF_SYNC, unknown_sqlstate);
      return NET_ASYNC_COMPLETE;
    }

    net_clear_error(net);
    mysql->info = nullptr;
    mysql->affected_rows = ~(my_ulonglong)0;
    /*
      Do not check the socket/protocol buffer on COM_QUIT as the
      result of a previous command might not have been read. This
      can happen if a client sends a query but does not reap
      the result before attempting to close the connection.
    */
    DBUG_ASSERT(command <= COM_END);
    net_clear(&mysql->net, (command != COM_QUIT));
    net_async->async_send_command_status = NET_ASYNC_SEND_COMMAND_WRITE_COMMAND;
  }

  MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);
  if (net_async->async_send_command_status ==
      NET_ASYNC_SEND_COMMAND_WRITE_COMMAND) {
    bool err;
    MYSQL_TRACE(SEND_COMMAND, mysql,
                (command, header_length, arg_length, header, arg));
    net_async_status status = net_write_command_nonblocking(
        net, (uchar)command, header, header_length, arg, arg_length, &err);
    if (status == NET_ASYNC_NOT_READY) {
      return NET_ASYNC_NOT_READY;
    }
    if (err) {
      DBUG_PRINT("error",
                 ("Can't send command to server. Error: %d", socket_errno));
      if (net->last_errno == ER_NET_PACKET_TOO_LARGE) {
        set_mysql_error(mysql, CR_NET_PACKET_TOO_LARGE, unknown_sqlstate);
        goto end;
      }
      end_server(mysql);
      /* reset net_async to null as its reference has been freed */
      net_async = nullptr;
      if (stmt_skip) goto end;
      set_mysql_error(mysql, CR_SERVER_GONE_ERROR, unknown_sqlstate);
      goto end;
    }
    MYSQL_TRACE(PACKET_SENT, mysql, (header_length + arg_length));
    if (skip_check) {
      result = false;
      goto end;
    } else {
      net_async->async_send_command_status = NET_ASYNC_SEND_COMMAND_READ_STATUS;
    }
  }

  if (net_async->async_send_command_status ==
      NET_ASYNC_SEND_COMMAND_READ_STATUS) {
    ulong pkt_len;
    net_async_status status =
        cli_safe_read_with_ok_nonblocking(mysql, true, nullptr, &pkt_len);
    if (status == NET_ASYNC_NOT_READY) {
      return NET_ASYNC_NOT_READY;
    }
    mysql->packet_length = pkt_len;
    result = (pkt_len == packet_error ? 1 : 0);
#if defined(CLIENT_PROTOCOL_TRACING)
    /*
      Return to READY_FOR_COMMAND protocol stage in case server reports
      error or sends OK packet.
    */
    if (!result || mysql->net.read_pos[0] == 0x00)
      MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);
#endif
  }
end:
  if (net_async)
    net_async->async_send_command_status = NET_ASYNC_SEND_COMMAND_IDLE;
  DBUG_PRINT("exit", ("result: %d", result));
  *ret = result;
  return NET_ASYNC_COMPLETE;
}

void free_old_query(MYSQL *mysql) {
  DBUG_TRACE;
  if (mysql->field_alloc) {
    free_root(mysql->field_alloc, MYF(0));
    init_alloc_root(PSI_NOT_INSTRUMENTED, mysql->field_alloc, 8192,
                    0); /* Assume rowlength < 8192 */
  }
  mysql->fields = nullptr;
  mysql->field_count = 0; /* For API */
  mysql->warning_count = 0;
  mysql->info = nullptr;
}

/**
  Finish reading of a partial result set from the server in asynchronous
  way. This function can return without completly flushing the result set,
  in such a case call this function again until result set in flushed.
  Read OK packet incase result set is not a data packet.

  @param[in]  mysql           connection handle
  @param[out] res             true in case of protocol error, false otherwise

  @retval     NET_ASYNC_NOT_READY  result set not flushed yet
  @retval     NET_ASYNC_COMPLETE   finished flushing result set
*/
static net_async_status flush_one_result_nonblocking(MYSQL *mysql, bool *res) {
  DBUG_TRACE;

  *res = false;
  while (true) {
    ulong packet_length;
    bool is_data_packet;
    if (cli_safe_read_nonblocking(mysql, &is_data_packet, &packet_length) ==
        NET_ASYNC_NOT_READY) {
      return NET_ASYNC_NOT_READY;
    }
    mysql->packet_length = packet_length;
    if (packet_length == packet_error) {
      *res = true;
      break;
    }
    if (mysql->net.read_pos[0] != 0 && !is_data_packet) {
      if (protocol_41(mysql)) {
        uchar *pos = mysql->net.read_pos + 1;
        if (mysql->server_capabilities & CLIENT_DEPRECATE_EOF &&
            !is_data_packet) {
          read_ok_ex(mysql, packet_length);
        } else {
          mysql->warning_count = uint2korr(pos);
          pos += 2;
          mysql->server_status = uint2korr(pos);
        }
        pos += 2;
      }
      break;
    }
  }
  return NET_ASYNC_COMPLETE;
}

/**
  Finish reading of a partial result set from the server.
  Get the EOF packet, and update mysql->status
  and mysql->warning_count.

  @return  true if a communication or protocol error, an error
           is set in this case, false otherwise.
*/

static bool flush_one_result(MYSQL *mysql) {
  ulong packet_length;
  bool is_data_packet;

  DBUG_ASSERT(mysql->status != MYSQL_STATUS_READY);

  do {
    packet_length = cli_safe_read(mysql, &is_data_packet);
    /*
      There is an error reading from the connection,
      or (sic!) there were no error and no
      data in the stream, i.e. no more data from the server.
      Since we know our position in the stream (somewhere in
      the middle of a result set), this latter case is an error too
      -- each result set must end with a EOF packet.
      cli_safe_read() has set an error for us, just return.
    */
    if (packet_length == packet_error) return true;
  } while (mysql->net.read_pos[0] == 0 || is_data_packet);

  /* Analyse final OK packet (EOF packet if it is old client) */

  if (protocol_41(mysql)) {
    uchar *pos = mysql->net.read_pos + 1;
    if (mysql->server_capabilities & CLIENT_DEPRECATE_EOF && !is_data_packet)
      read_ok_ex(mysql, packet_length);
    else {
      mysql->warning_count = uint2korr(pos);
      pos += 2;
      mysql->server_status = uint2korr(pos);
    }
    pos += 2;
  }
#if defined(CLIENT_PROTOCOL_TRACING)
  if (mysql->server_status & SERVER_MORE_RESULTS_EXISTS)
    MYSQL_TRACE_STAGE(mysql, WAIT_FOR_RESULT);
  else
    MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);
#endif
  return false;
}

/**
  Read a packet from network. If it's an OK packet, flush it.

  @return  true if error, false otherwise. In case of
           success, is_ok_packet is set to true or false,
           based on what we got from network.
*/

static bool opt_flush_ok_packet(MYSQL *mysql, bool *is_ok_packet) {
  bool is_data_packet;
  ulong packet_length = cli_safe_read(mysql, &is_data_packet);

  if (packet_length == packet_error) return true;

  /* cli_safe_read always reads a non-empty packet. */
  DBUG_ASSERT(packet_length);

  *is_ok_packet =
      ((mysql->net.read_pos[0] == 0) ||
       ((mysql->server_capabilities & CLIENT_DEPRECATE_EOF) &&
        mysql->net.read_pos[0] == 254 && packet_length < MAX_PACKET_LENGTH));
  if (*is_ok_packet) {
    read_ok_ex(mysql, packet_length);
#if defined(CLIENT_PROTOCOL_TRACING)
    if (mysql->server_status & SERVER_MORE_RESULTS_EXISTS)
      MYSQL_TRACE_STAGE(mysql, WAIT_FOR_RESULT);
    else
      MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);
#endif
  }

  return false;
}

static net_async_status cli_flush_use_result_nonblocking(
    MYSQL *mysql, bool flush_all_results MY_ATTRIBUTE((unused))) {
  DBUG_TRACE;
  /*
    flush_all_results is only used for mysql_stmt_close, and async is not
    supported for that.
  */
  DBUG_ASSERT(!flush_all_results);
  bool res;
  return flush_one_result_nonblocking(mysql, &res);
}

/*
  Flush result set sent from server
*/

static void cli_flush_use_result(MYSQL *mysql, bool flush_all_results) {
  /* Clear the current execution status */
  DBUG_TRACE;
  DBUG_PRINT("warning", ("Not all packets read, clearing them"));

  if (flush_one_result(mysql)) return; /* An error occurred */

  if (!flush_all_results) return;

  while (mysql->server_status & SERVER_MORE_RESULTS_EXISTS) {
    bool is_ok_packet;
    if (opt_flush_ok_packet(mysql, &is_ok_packet))
      return; /* An error occurred. */
    if (is_ok_packet) {
      /*
        Indeed what we got from network was an OK packet, and we
        know that OK is the last one in a multi-result-set, so
        just return.
      */
      return;
    }

    /*
      It's a result set, not an OK packet. A result set contains
      of two result set subsequences: field metadata, terminated
      with EOF packet, and result set data, again terminated with
      EOF packet. Read and flush them.
    */
    MYSQL_TRACE_STAGE(mysql, WAIT_FOR_FIELD_DEF);
    if (!(mysql->server_capabilities & CLIENT_DEPRECATE_EOF)) {
      if (flush_one_result(mysql)) return; /* An error occurred. */
    } else {
      uchar *pos = (uchar *)mysql->net.read_pos;
      ulong field_count = net_field_length(&pos);
      if (read_com_query_metadata(mysql, pos, field_count)) {
        return;
      } else {
        free_root(mysql->field_alloc, MYF(0));
      }
    }
    MYSQL_TRACE_STAGE(mysql, WAIT_FOR_ROW);
    if (flush_one_result(mysql)) return;
  }
}

#ifdef _WIN32
static bool is_NT(void) {
  char *os = getenv("OS");
  return (os && !strcmp(os, "Windows_NT")) ? 1 : 0;
}
#endif

#ifdef CHECK_LICENSE
/**
  Check server side variable 'license'.

  If the variable does not exist or does not contain 'Commercial',
  we're talking to non-commercial server from commercial client.

  @retval  0   success
  @retval  !0  network error or the server is not commercial.
               Error code is saved in mysql->net.last_errno.
*/

static int check_license(MYSQL *mysql) {
  MYSQL_ROW row;
  MYSQL_RES *res;
  NET *net = &mysql->net;
  static const char query[] = "SELECT @@license";
  static const char required_license[] = STRINGIFY_ARG(LICENSE);

  if (mysql_real_query(mysql, query, (ulong)(sizeof(query) - 1))) {
    if (net->last_errno == ER_UNKNOWN_SYSTEM_VARIABLE) {
      set_mysql_extended_error(mysql, CR_WRONG_LICENSE, unknown_sqlstate,
                               ER_CLIENT(CR_WRONG_LICENSE), required_license);
    }
    return 1;
  }
  if (!(res = mysql_use_result(mysql))) return 1;
  row = mysql_fetch_row(res);
  /*
    If no rows in result set, or column value is NULL (none of these
    two is ever true for server variables now), or column value
    mismatch, set wrong license error.
  */
  if (!net->last_errno &&
      (!row || !row[0] ||
       strncmp(row[0], required_license, sizeof(required_license)))) {
    set_mysql_extended_error(mysql, CR_WRONG_LICENSE, unknown_sqlstate,
                             ER_CLIENT(CR_WRONG_LICENSE), required_license);
  }
  mysql_free_result(res);
  return net->last_errno;
}
#endif /* CHECK_LICENSE */

/**************************************************************************
  Shut down connection
**************************************************************************/

void end_server(MYSQL *mysql) {
  int save_errno = errno;
  DBUG_TRACE;
  if (mysql->net.vio != nullptr) {
#ifndef DBUG_OFF
    char desc[VIO_DESCRIPTION_SIZE];
    vio_description(mysql->net.vio, desc);
    DBUG_PRINT("info", ("Net: %s", desc));
#endif  // DBUG_OFF
#ifdef MYSQL_SERVER
    slave_io_thread_detach_vio();
#endif
    vio_delete(mysql->net.vio);
    mysql->net.vio = nullptr; /* Marker */
    mysql_prune_stmt_list(mysql);
  }
  net_end(&mysql->net);
  //  net_extension_free(&mysql->net);
  free_old_query(mysql);
  errno = save_errno;
  MYSQL_TRACE(DISCONNECTED, mysql, ());
}

/**
  Frees the memory allocated for a result, set by APIs which would have
  returned rows.

  @param[in]   result              buffer which needs to be freed

  @retval      NET_ASYNC_NOT_READY operation not complete, retry again
  @retval      NET_ASYNC_COMPLETE  operation complete
*/
net_async_status STDCALL mysql_free_result_nonblocking(MYSQL_RES *result) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("mysql_res: %p", result));
  if (!result) return NET_ASYNC_COMPLETE;

  MYSQL *mysql = result->handle;
  if (mysql) {
    if (mysql->unbuffered_fetch_owner == &result->unbuffered_fetch_cancelled)
      mysql->unbuffered_fetch_owner = nullptr;
    if (mysql->status == MYSQL_STATUS_USE_RESULT) {
      if (mysql->methods->flush_use_result_nonblocking(mysql, false) ==
          NET_ASYNC_NOT_READY) {
        return NET_ASYNC_NOT_READY;
      }
      mysql->status = MYSQL_STATUS_READY;
      if (mysql->unbuffered_fetch_owner) *mysql->unbuffered_fetch_owner = true;
    }
  }
  free_rows(result->data);
  if (result->field_alloc) {
    free_root(result->field_alloc, MYF(0));
    my_free(result->field_alloc);
  }
  my_free(result->row);
  my_free(result);

  return NET_ASYNC_COMPLETE;
}

void STDCALL mysql_free_result(MYSQL_RES *result) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("mysql_res: %p", result));
  if (result) {
    MYSQL *mysql = result->handle;
    if (mysql) {
      if (mysql->unbuffered_fetch_owner == &result->unbuffered_fetch_cancelled)
        mysql->unbuffered_fetch_owner = nullptr;
      if (mysql->status == MYSQL_STATUS_USE_RESULT) {
        (*mysql->methods->flush_use_result)(mysql, false);
        mysql->status = MYSQL_STATUS_READY;
        if (mysql->unbuffered_fetch_owner)
          *mysql->unbuffered_fetch_owner = true;
      }
    }
    free_rows(result->data);
    if (result->field_alloc) {
      free_root(result->field_alloc, MYF(0));
      my_free(result->field_alloc);
    }
    my_free(result->row);
    my_free(result);
  }
}

/****************************************************************************
  Get options from my.cnf
****************************************************************************/

static const char *default_options[] = {"port",
                                        "socket",
                                        "compress",
                                        "password",
                                        "pipe",
                                        "timeout",
                                        "user",
                                        "init-command",
                                        "host",
                                        "database",
                                        "debug",
                                        "return-found-rows",
                                        "ssl-key",
                                        "ssl-cert",
                                        "ssl-ca",
                                        "ssl-capath",
                                        "character-sets-dir",
                                        "default-character-set",
                                        "interactive-timeout",
                                        "connect-timeout",
                                        "local-infile",
                                        "disable-local-infile",
                                        "ssl-cipher",
                                        "max-allowed-packet",
                                        "protocol",
                                        "shared-memory-base-name",
                                        "multi-results",
                                        "multi-statements",
                                        "multi-queries",
                                        "report-data-truncation",
                                        "plugin-dir",
                                        "default-auth",
                                        "bind-address",
                                        "ssl-crl",
                                        "ssl-crlpath",
                                        "enable-cleartext-plugin",
                                        "tls-version",
                                        "ssl_mode",
                                        "optional-resultset-metadata",
                                        "ssl-fips-mode",
                                        "tls-ciphersuites",
                                        NullS};
enum option_id {
  OPT_port = 1,
  OPT_socket,
  OPT_compress,
  OPT_password,
  OPT_pipe,
  OPT_timeout,
  OPT_user,
  OPT_init_command,
  OPT_host,
  OPT_database,
  OPT_debug,
  OPT_return_found_rows,
  OPT_ssl_key,
  OPT_ssl_cert,
  OPT_ssl_ca,
  OPT_ssl_capath,
  OPT_character_sets_dir,
  OPT_default_character_set,
  OPT_interactive_timeout,
  OPT_connect_timeout,
  OPT_local_infile,
  OPT_disable_local_infile,
  OPT_ssl_cipher,
  OPT_max_allowed_packet,
  OPT_protocol,
  OPT_shared_memory_base_name,
  OPT_multi_results,
  OPT_multi_statements,
  OPT_multi_queries,
  OPT_report_data_truncation,
  OPT_plugin_dir,
  OPT_default_auth,
  OPT_bind_address,
  OPT_ssl_crl,
  OPT_ssl_crlpath,
  OPT_enable_cleartext_plugin,
  OPT_tls_version,
  OPT_ssl_mode,
  OPT_optional_resultset_metadata,
  OPT_ssl_fips_mode,
  OPT_tls_ciphersuites,
  OPT_keep_this_one_last
};

static TYPELIB option_types = {array_elements(default_options) - 1, "options",
                               default_options, nullptr};

const char *sql_protocol_names_lib[] = {"TCP", "SOCKET", "PIPE", "MEMORY",
                                        NullS};
TYPELIB sql_protocol_typelib = {array_elements(sql_protocol_names_lib) - 1, "",
                                sql_protocol_names_lib, nullptr};

static int add_init_command(struct st_mysql_options *options, const char *cmd) {
  char *tmp;

  if (!options->init_commands) {
    void *rawmem = my_malloc(key_memory_mysql_options,
                             sizeof(Init_commands_array), MYF(MY_WME));
    if (!rawmem) return 1;
    options->init_commands =
        new (rawmem) Init_commands_array(key_memory_mysql_options);
  }

  if (!(tmp = my_strdup(key_memory_mysql_options, cmd, MYF(MY_WME))) ||
      options->init_commands->push_back(tmp)) {
    my_free(tmp);
    return 1;
  }

  return 0;
}

static char *set_ssl_option_unpack_path(const char *arg) {
  char *opt_var = nullptr;
  if (arg) {
    char *buff =
        (char *)my_malloc(key_memory_mysql_options, FN_REFLEN + 1, MYF(MY_WME));
    unpack_filename(buff, arg);
    opt_var = my_strdup(key_memory_mysql_options, buff, MYF(MY_WME));
    my_free(buff);
  }
  return opt_var;
}

void mysql_read_default_options(struct st_mysql_options *options,
                                const char *filename, const char *group) {
  int argc;
  char *argv_buff[1], **argv;
  const char *groups[3];
  DBUG_TRACE;
  DBUG_PRINT("enter",
             ("file: %s  group: %s", filename, group ? group : "NULL"));

  static_assert(OPT_keep_this_one_last == array_elements(default_options),
                "OPT_keep_this_one_last needs to be the last element.");

  argc = 1;
  argv = argv_buff;
  argv_buff[0] = const_cast<char *>("client");
  groups[0] = "client";
  groups[1] = group;
  groups[2] = nullptr;

  MEM_ROOT alloc{PSI_NOT_INSTRUMENTED, 512};
  my_load_defaults(filename, groups, &argc, &argv, &alloc, nullptr);
  if (argc != 1) /* If some default option */
  {
    char **option = argv;
    while (*++option) {
      if (my_getopt_is_args_separator(option[0])) /* skip arguments separator */
        continue;
      /* DBUG_PRINT("info",("option: %s",option[0])); */
      if (option[0][0] == '-' && option[0][1] == '-') {
        char *end = strchr(*option, '=');
        char *opt_arg = nullptr;
        if (end != nullptr) {
          opt_arg = end + 1;
          *end = 0; /* Remove '=' */
        }
        /* Change all '_' in variable name to '-' */
        for (end = *option; end != nullptr; end = strchr(end, '_')) *end = '-';
        switch (find_type(*option + 2, &option_types, FIND_TYPE_BASIC)) {
          case OPT_port:
            if (opt_arg) options->port = atoi(opt_arg);
            break;
          case OPT_socket:
            if (opt_arg) {
              my_free(options->unix_socket);
              options->unix_socket =
                  my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            }
            break;
          case OPT_compress:
            options->compress = true;
            options->client_flag |= CLIENT_COMPRESS;
            break;
          case OPT_password:
            if (opt_arg) {
              my_free(options->password);
              options->password =
                  my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            }
            break;
          case OPT_pipe:
            options->protocol = MYSQL_PROTOCOL_PIPE;
            break;
          case OPT_connect_timeout:
          case OPT_timeout:
            if (opt_arg) options->connect_timeout = atoi(opt_arg);
            break;
          case OPT_user:
            if (opt_arg) {
              my_free(options->user);
              options->user =
                  my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            }
            break;
          case OPT_init_command:
            add_init_command(options, opt_arg);
            break;
          case OPT_host:
            if (opt_arg) {
              my_free(options->host);
              options->host =
                  my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            }
            break;
          case OPT_database:
            if (opt_arg) {
              my_free(options->db);
              options->db =
                  my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            }
            break;
          case OPT_debug:
#ifndef MYSQL_SERVER
            mysql_debug(opt_arg ? opt_arg : "d:t:o,/tmp/client.trace");
            break;
#endif
          case OPT_return_found_rows:
            options->client_flag |= CLIENT_FOUND_ROWS;
            break;
          case OPT_ssl_key:
            my_free(options->ssl_key);
            options->ssl_key =
                my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            break;
          case OPT_ssl_cert:
            my_free(options->ssl_cert);
            options->ssl_cert =
                my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            break;
          case OPT_ssl_ca:
            my_free(options->ssl_ca);
            options->ssl_ca =
                my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            break;
          case OPT_ssl_capath:
            my_free(options->ssl_capath);
            options->ssl_capath =
                my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            break;
          case OPT_ssl_cipher:
            my_free(options->ssl_cipher);
            options->ssl_cipher =
                my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            break;
          case OPT_tls_ciphersuites:
            EXTENSION_SET_STRING(options, tls_ciphersuites, opt_arg);
            break;
          case OPT_tls_version:
            EXTENSION_SET_SSL_STRING(options, tls_version, opt_arg,
                                     SSL_MODE_PREFERRED);
            break;
          case OPT_ssl_crl:
            EXTENSION_SET_SSL_STRING(options, ssl_crl, opt_arg,
                                     SSL_MODE_PREFERRED);
            break;
          case OPT_ssl_crlpath:
            EXTENSION_SET_SSL_STRING(options, ssl_crlpath, opt_arg,
                                     SSL_MODE_PREFERRED);
            break;
          case OPT_character_sets_dir:
            my_free(options->charset_dir);
            options->charset_dir =
                my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            break;
          case OPT_default_character_set:
            my_free(options->charset_name);
            options->charset_name =
                my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            break;
          case OPT_interactive_timeout:
            options->client_flag |= CLIENT_INTERACTIVE;
            break;
          case OPT_local_infile:
            if (!opt_arg || atoi(opt_arg) != 0)
              options->client_flag |= CLIENT_LOCAL_FILES;
            else
              options->client_flag &= ~CLIENT_LOCAL_FILES;
            break;
          case OPT_disable_local_infile:
            options->client_flag &= ~CLIENT_LOCAL_FILES;
            break;
          case OPT_max_allowed_packet:
            if (opt_arg) options->max_allowed_packet = atoi(opt_arg);
            break;
          case OPT_protocol:
            if ((options->protocol = find_type(opt_arg, &sql_protocol_typelib,
                                               FIND_TYPE_BASIC)) <= 0) {
              my_message_local(ERROR_LEVEL, EE_UNKNOWN_PROTOCOL_OPTION,
                               opt_arg);
              exit(1);
            }
            break;
          case OPT_shared_memory_base_name:
#if defined(_WIN32)
            if (options->shared_memory_base_name != def_shared_memory_base_name)
              my_free(options->shared_memory_base_name);
            options->shared_memory_base_name =
                my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
#endif
            break;
          case OPT_multi_results:
            options->client_flag |= CLIENT_MULTI_RESULTS;
            break;
          case OPT_multi_statements:
          case OPT_multi_queries:
            options->client_flag |=
                CLIENT_MULTI_STATEMENTS | CLIENT_MULTI_RESULTS;
            break;
          case OPT_report_data_truncation:
            options->report_data_truncation =
                opt_arg ? (atoi(opt_arg) != 0) : true;
            break;
          case OPT_plugin_dir: {
            char buff[FN_REFLEN], buff2[FN_REFLEN];
            if (strlen(opt_arg) >= FN_REFLEN) opt_arg[FN_REFLEN] = '\0';
            if (my_realpath(buff, opt_arg, 0)) {
              DBUG_PRINT("warning",
                         ("failed to normalize the plugin path: %s", opt_arg));
              break;
            }
            convert_dirname(buff2, buff, nullptr);
            EXTENSION_SET_STRING(options, plugin_dir, buff2);
          } break;
          case OPT_default_auth:
            EXTENSION_SET_STRING(options, default_auth, opt_arg);
            break;
          case OPT_bind_address:
            my_free(options->bind_address);
            options->bind_address =
                my_strdup(key_memory_mysql_options, opt_arg, MYF(MY_WME));
            break;
          case OPT_enable_cleartext_plugin:
            ENSURE_EXTENSIONS_PRESENT(options);
            options->extension->enable_cleartext_plugin =
                (!opt_arg || atoi(opt_arg) != 0) ? true : false;
            break;
          case OPT_optional_resultset_metadata:
            if (!opt_arg || atoi(opt_arg) != 0)
              options->client_flag |= CLIENT_OPTIONAL_RESULTSET_METADATA;
            else
              options->client_flag &= ~CLIENT_OPTIONAL_RESULTSET_METADATA;
            break;

          default:
            DBUG_PRINT("warning", ("unknown option: %s", option[0]));
        }
      }
    }
  }
}

/**************************************************************************
  Get column lengths of the current row
  If one uses mysql_use_result, res->lengths contains the length information,
  else the lengths are calculated from the offset between pointers.
**************************************************************************/

static void cli_fetch_lengths(ulong *to, MYSQL_ROW column,
                              unsigned int field_count) {
  ulong *prev_length;
  char *start = nullptr;
  MYSQL_ROW end;

  prev_length = nullptr; /* Keep gcc happy */
  for (end = column + field_count + 1; column != end; column++, to++) {
    if (!*column) {
      *to = 0; /* Null */
      continue;
    }
    if (start) /* Found end of prev string */
      *prev_length = (ulong)(*column - start - 1);
    start = *column;
    prev_length = to;
  }
}

/**
  Read field metadata from field descriptor and store it in MYSQL_FIELD
  structure. String values in MYSQL_FIELD are allocated in a given allocator
  root.

  @param mysql          connection handle
  @param alloc          memory allocator root
  @param default_value  flag telling if default values should be read from
                        descriptor
  @param server_capabilities  protocol capability flags which determine format
  of the descriptor
  @param row            field descriptor
  @param field          address of MYSQL_FIELD structure to store metadata in.

  @returns 0 on success.
*/

static int unpack_field(MYSQL *mysql, MEM_ROOT *alloc, bool default_value,
                        uint server_capabilities, MYSQL_ROWS *row,
                        MYSQL_FIELD *field) {
  ulong lengths[9]; /* Max length of each field */
  DBUG_TRACE;

  if (!field) {
    set_mysql_error(mysql, CR_UNKNOWN_ERROR, unknown_sqlstate);
    return 1;
  }

  memset(field, 0, sizeof(MYSQL_FIELD));

  if (server_capabilities & CLIENT_PROTOCOL_41) {
    uchar *pos;
    /* fields count may be wrong */
    cli_fetch_lengths(&lengths[0], row->data, default_value ? 8 : 7);
    field->catalog = strmake_root(alloc, (char *)row->data[0], lengths[0]);
    field->db = strmake_root(alloc, (char *)row->data[1], lengths[1]);
    field->table = strmake_root(alloc, (char *)row->data[2], lengths[2]);
    field->org_table = strmake_root(alloc, (char *)row->data[3], lengths[3]);
    field->name = strmake_root(alloc, (char *)row->data[4], lengths[4]);
    field->org_name = strmake_root(alloc, (char *)row->data[5], lengths[5]);

    field->catalog_length = lengths[0];
    field->db_length = lengths[1];
    field->table_length = lengths[2];
    field->org_table_length = lengths[3];
    field->name_length = lengths[4];
    field->org_name_length = lengths[5];

    /* Unpack fixed length parts */
    if (lengths[6] != 12) {
      /* malformed packet. signal an error. */
      set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
      return 1;
    }

    pos = (uchar *)row->data[6];
    field->charsetnr = uint2korr(pos);
    field->length = (uint)uint4korr(pos + 2);
    field->type = (enum enum_field_types)pos[6];
    field->flags = uint2korr(pos + 7);
    field->decimals = (uint)pos[9];

    if (IS_NUM(field->type)) field->flags |= NUM_FLAG;
    if (default_value && row->data[7]) {
      field->def = strmake_root(alloc, (char *)row->data[7], lengths[7]);
      field->def_length = lengths[7];
    } else
      field->def = nullptr;
    field->max_length = 0;
  }
#ifndef DELETE_SUPPORT_OF_4_0_PROTOCOL
  else {
    /*
      If any of the row->data[] below is NULL, it can result in a
      crash. Error out early as it indicates a malformed packet.
      For data[0], data[1] and data[5], strmake_root() will handle
      NULL values.
    */
    if (!row->data[2] || !row->data[3] || !row->data[4]) {
      set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
      return 1;
    }

    cli_fetch_lengths(&lengths[0], row->data, default_value ? 6 : 5);
    field->org_table = field->table =
        strmake_root(alloc, (char *)row->data[0], lengths[0]);
    field->name = strmake_root(alloc, (char *)row->data[1], lengths[1]);
    field->length = (uint)uint3korr((uchar *)row->data[2]);
    field->type = (enum enum_field_types)(uchar)row->data[3][0];

    field->catalog = const_cast<char *>("");
    field->db = const_cast<char *>("");
    field->catalog_length = 0;
    field->db_length = 0;
    field->org_table_length = field->table_length = lengths[0];
    field->name_length = lengths[1];

    if (server_capabilities & CLIENT_LONG_FLAG) {
      if (lengths[4] != 3) {
        /* malformed packet. signal an error. */
        set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
        return 1;
      }
      field->flags = uint2korr((uchar *)row->data[4]);
      field->decimals = (uint)(uchar)row->data[4][2];
    } else {
      if (lengths[4] != 2) {
        /* malformed packet. signal an error. */
        set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
        return 1;
      }
      field->flags = (uint)(uchar)row->data[4][0];
      field->decimals = (uint)(uchar)row->data[4][1];
    }
    if (IS_NUM(field->type)) field->flags |= NUM_FLAG;
    if (default_value && row->data[5]) {
      field->def = strmake_root(alloc, (char *)row->data[5], lengths[5]);
      field->def_length = lengths[5];
    } else
      field->def = nullptr;
    field->max_length = 0;
  }
#endif /* DELETE_SUPPORT_OF_4_0_PROTOCOL */
  return 0;
}

/***************************************************************************
  Change field rows to field structs
***************************************************************************/

MYSQL_FIELD *unpack_fields(MYSQL *mysql, MYSQL_ROWS *data, MEM_ROOT *alloc,
                           uint fields, bool default_value,
                           uint server_capabilities) {
  MYSQL_ROWS *row;
  MYSQL_FIELD *field, *result;
  DBUG_TRACE;

  field = result = (MYSQL_FIELD *)alloc->Alloc((uint)sizeof(*field) * fields);
  if (!result) {
    set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
    return nullptr;
  }
  memset(field, 0, sizeof(MYSQL_FIELD) * fields);
  for (row = data; row; row = row->next, field++) {
    /* fields count may be wrong */
    if (field < result || static_cast<uint>(field - result) >= fields) {
      return nullptr;
    }
    if (unpack_field(mysql, alloc, default_value, server_capabilities, row,
                     field)) {
      return nullptr;
    }
  }
  return result;
}

/**
  Read metadata resultset from server in asynchronous way.

  @param[in]    mysql           connection handle
  @param[in]    alloc           memory allocator root
  @param[in]    field_count     total number of fields
  @param[in]    field           number of columns in single field descriptor
  @param[out]   ret             an array of field rows

  @retval     NET_ASYNC_NOT_READY  metadata resultset not read completely
  @retval     NET_ASYNC_COMPLETE   finished reading metadata resultset
*/
net_async_status cli_read_metadata_ex_nonblocking(MYSQL *mysql, MEM_ROOT *alloc,
                                                  ulong field_count,
                                                  unsigned int field,
                                                  MYSQL_FIELD **ret) {
  DBUG_TRACE;
  uchar *pos;
  ulong pkt_len;
  NET *net = &mysql->net;
  MYSQL_ASYNC *async_data = ASYNC_DATA(mysql);
  *ret = nullptr;

  if (!async_data->async_read_metadata_field_len) {
    async_data->async_read_metadata_field_len =
        (ulong *)alloc->Alloc(sizeof(ulong) * field);
  }
  if (!async_data->async_read_metadata_fields) {
    async_data->async_read_metadata_fields =
        (MYSQL_FIELD *)alloc->Alloc((uint)sizeof(MYSQL_FIELD) * field_count);
    if (async_data->async_read_metadata_fields)
      memset(async_data->async_read_metadata_fields, 0,
             sizeof(MYSQL_FIELD) * field_count);
  }

  if (!async_data->async_read_metadata_fields) {
    set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
    goto end;
  }

  if (!async_data->async_read_metadata_data.data) {
    async_data->async_read_metadata_data.data =
        (MYSQL_ROW)alloc->Alloc(sizeof(char *) * (field + 1));
    memset(async_data->async_read_metadata_data.data, 0,
           sizeof(char *) * (field + 1));
  }

  /*
    In this below loop we read each column info as 1 single row
    and save it in mysql->fields array
  */
  while (async_data->async_read_metadata_cur_field < field_count) {
    int res;
    if (read_one_row_nonblocking(mysql, field,
                                 async_data->async_read_metadata_data.data,
                                 async_data->async_read_metadata_field_len,
                                 &res) == NET_ASYNC_NOT_READY) {
      return NET_ASYNC_NOT_READY;
    }

    if (res == -1) {
      goto end;
    }

    if (unpack_field(mysql, alloc, false, mysql->server_capabilities,
                     &async_data->async_read_metadata_data,
                     async_data->async_read_metadata_fields +
                         async_data->async_read_metadata_cur_field)) {
      goto end;
    }
    async_data->async_read_metadata_cur_field++;
  }

  /* Read EOF packet in case of old client */
  if (!(mysql->server_capabilities & CLIENT_DEPRECATE_EOF)) {
    if (cli_safe_read_nonblocking(mysql, nullptr, &pkt_len) ==
        NET_ASYNC_NOT_READY) {
      return NET_ASYNC_NOT_READY;
    }

    if (pkt_len == packet_error) {
      goto end;
    }

    pos = net->read_pos;
    if (*pos == 254) {
      mysql->warning_count = uint2korr(pos + 1);
      mysql->server_status = uint2korr(pos + 3);
    }
  }
  *ret = async_data->async_read_metadata_fields;

end:
  async_data->async_read_metadata_field_len = nullptr;
  async_data->async_read_metadata_fields = nullptr;
  memset(&async_data->async_read_metadata_data, 0,
         sizeof(async_data->async_read_metadata_data));
  async_data->async_read_metadata_cur_field = 0;
  return NET_ASYNC_COMPLETE;
}

/**
  Read metadata resultset from server
  Memory allocated in a given allocator root.

  @param[in]    mysql           connection handle
  @param[in]    alloc           memory allocator root
  @param[in]    field_count     total number of fields
  @param[in]    field           number of columns in single field descriptor

  @retval an array of field rows

*/
MYSQL_FIELD *cli_read_metadata_ex(MYSQL *mysql, MEM_ROOT *alloc,
                                  ulong field_count, unsigned int field) {
  ulong *len;
  uint f;
  uchar *pos;
  MYSQL_FIELD *fields, *result;
  MYSQL_ROWS data;
  NET *net = &mysql->net;
  size_t size;

  DBUG_TRACE;

  len = (ulong *)alloc->Alloc(sizeof(ulong) * field);
  size = sizeof(MYSQL_FIELD) * field_count;

  if (field_count != (size / sizeof(MYSQL_FIELD))) {
    set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
    end_server(mysql);
    return nullptr;
  }

  fields = result = (MYSQL_FIELD *)alloc->Alloc(size);
  if (!result) {
    set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
    end_server(mysql);
    return nullptr;
  }
  memset(fields, 0, sizeof(MYSQL_FIELD) * field_count);

  data.data = (MYSQL_ROW)alloc->Alloc(sizeof(char *) * (field + 1));
  memset(data.data, 0, sizeof(char *) * (field + 1));

  /*
    In this below loop we read each column info as 1 single row
    and save it in mysql->fields array
  */
  for (f = 0; f < field_count; ++f) {
    if (read_one_row(mysql, field, data.data, len) == -1) return nullptr;
    if (unpack_field(mysql, alloc, false, mysql->server_capabilities, &data,
                     fields++))
      return nullptr;
  }
  /* Read EOF packet in case of old client */
  if (!(mysql->server_capabilities & CLIENT_DEPRECATE_EOF)) {
    if (packet_error == cli_safe_read(mysql, nullptr)) return nullptr;
    pos = net->read_pos;
    if (*pos == 254) {
      mysql->warning_count = uint2korr(pos + 1);
      mysql->server_status = uint2korr(pos + 3);
    }
  }
  return result;
}

static int alloc_field_alloc(MYSQL *mysql) {
  if (mysql->field_alloc == nullptr) {
    mysql->field_alloc = (MEM_ROOT *)my_malloc(
        key_memory_MYSQL, sizeof(MEM_ROOT), MYF(MY_WME | MY_ZEROFILL));
    if (mysql->field_alloc == nullptr) {
      set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
      return 1;
    }
    init_alloc_root(PSI_NOT_INSTRUMENTED, mysql->field_alloc, 8192,
                    0); /* Assume rowlength < 8192 */
  }
  /* At this point the NET is receiving a resultset. max packet should be set */
  DBUG_ASSERT(mysql->net.max_packet_size != 0);
  /* Limit the size of the columns buffer to MAX packet size or 1M */
  mysql->field_alloc->set_max_capacity(
      std::max(1024UL * 1024UL, mysql->net.max_packet_size));
  return 0;
}

/**
  Read metadata resultset from server

  @param[in]    mysql           connection handle
  @param[in]    field_count     total number of fields
  @param[in]    field           number of columns in single field descriptor

  @retval an array of field rows

*/
MYSQL_FIELD *cli_read_metadata(MYSQL *mysql, ulong field_count,
                               unsigned int field) {
  alloc_field_alloc(mysql);
  return cli_read_metadata_ex(mysql, mysql->field_alloc, field_count, field);
}

/**
  Helper method to read metadata in asynchronous way.
*/
static net_async_status cli_read_metadata_nonblocking(MYSQL *mysql,
                                                      ulong field_count,
                                                      unsigned int field,
                                                      MYSQL_FIELD **ret) {
  alloc_field_alloc(mysql);
  if (cli_read_metadata_ex_nonblocking(mysql, mysql->field_alloc, field_count,
                                       field, ret) == NET_ASYNC_NOT_READY) {
    return NET_ASYNC_NOT_READY;
  }
  return NET_ASYNC_COMPLETE;
}

/**
  Read resultset metadata returned by COM_QUERY command.

  @param[in]    mysql           Client connection handle.
  @param[in]    pos             Position in the packet where the metadata
  starts.
  @param[in]    field_count     Number of columns in the field descriptor.

  @retval       0               Success.
  @retval       1               Error.
*/
static int read_com_query_metadata(MYSQL *mysql, uchar *pos,
                                   ulong field_count) {
  /* Store resultset metadata flag. */
  if (mysql->client_flag & CLIENT_OPTIONAL_RESULTSET_METADATA) {
    mysql->resultset_metadata = static_cast<enum enum_resultset_metadata>(*pos);
  } else {
    mysql->resultset_metadata = RESULTSET_METADATA_FULL;
  }

  switch (mysql->resultset_metadata) {
    case RESULTSET_METADATA_FULL:
      /* Read metadata. */
      MYSQL_TRACE_STAGE(mysql, WAIT_FOR_FIELD_DEF);

      if (!(mysql->fields = cli_read_metadata(mysql, field_count,
                                              protocol_41(mysql) ? 7 : 5))) {
        free_root(mysql->field_alloc, MYF(0));
        return 1;
      }
      break;

    case RESULTSET_METADATA_NONE:
      /* Skip metadata. */
      mysql->fields = nullptr;
      break;

    default:
      /* Unknown metadata flag. */
      mysql->fields = nullptr;
      return 1;
  }

  return 0;
}

/**
  Read resultset metadata returned by COM_QUERY command in asynchronous way.

  @param[in]    mysql           Client connection handle.
  @param[in]    pos             Position in the packet where the metadata
                                starts.
  @param[in]    field_count     Number of columns in the field descriptor.
  @param[out]   res             set to false incase of success and true for
  error.

  @retval     NET_ASYNC_NOT_READY  metadata resultset not read completely
  @retval     NET_ASYNC_COMPLETE   finished reading metadata resultset
*/
static net_async_status read_com_query_metadata_nonblocking(MYSQL *mysql,
                                                            uchar *pos,
                                                            ulong field_count,
                                                            int *res) {
  DBUG_TRACE;
  /* pos is only set on the first reentrant call. */
  if (pos) {
    /* Store resultset metadata flag. */
    if (mysql->client_flag & CLIENT_OPTIONAL_RESULTSET_METADATA) {
      mysql->resultset_metadata =
          static_cast<enum enum_resultset_metadata>(*pos);
    } else {
      mysql->resultset_metadata = RESULTSET_METADATA_FULL;
    }
  }

  switch (mysql->resultset_metadata) {
    case RESULTSET_METADATA_FULL:
      /* Read metadata. */
      MYSQL_TRACE_STAGE(mysql, WAIT_FOR_FIELD_DEF);

      if (cli_read_metadata_nonblocking(
              mysql, field_count, protocol_41(mysql) ? 7 : 5, &mysql->fields) ==
          NET_ASYNC_NOT_READY) {
        return NET_ASYNC_NOT_READY;
      }

      if (!mysql->fields) {
        free_root(mysql->field_alloc, MYF(0));
        *res = 1;
        return NET_ASYNC_COMPLETE;
      }
      break;

    case RESULTSET_METADATA_NONE:
      /* Skip metadata. */
      mysql->fields = nullptr;
      break;

    default:
      /* Unknown metadata flag. */
      mysql->fields = nullptr;
      *res = 1;
      return NET_ASYNC_COMPLETE;
  }

  *res = 0;
  return NET_ASYNC_COMPLETE;
}

net_async_status cli_read_rows_nonblocking(MYSQL *mysql,
                                           MYSQL_FIELD *mysql_fields,
                                           unsigned int fields,
                                           MYSQL_DATA **result_out) {
  uint field;
  ulong pkt_len;
  ulong len;
  uchar *cp;
  char *to, *end_to;
  MYSQL_ROWS *cur;
  NET *net = &mysql->net;
  bool is_data_packet;
  DBUG_TRACE;
  MYSQL_ASYNC *async_context = ASYNC_DATA(mysql);
  NET_ASYNC *net_async = NET_ASYNC_DATA(net);
  *result_out = nullptr;

  if (cli_safe_read_nonblocking(mysql, &is_data_packet, &pkt_len) ==
      NET_ASYNC_NOT_READY) {
    return NET_ASYNC_NOT_READY;
  }

  mysql->packet_length = pkt_len;
  if (pkt_len == packet_error) {
    if (net_async->read_rows_is_first_read) {
      free_rows(async_context->rows_result_buffer);
      async_context->rows_result_buffer = nullptr;
    }
    net_async->read_rows_is_first_read = true;
    return NET_ASYNC_COMPLETE;
  }

  if (net_async->read_rows_is_first_read) {
    MYSQL_DATA *result;
    if (!(result =
              (MYSQL_DATA *)my_malloc(key_memory_MYSQL_DATA, sizeof(MYSQL_DATA),
                                      MYF(MY_WME | MY_ZEROFILL))) ||
        !(result->alloc =
              (MEM_ROOT *)my_malloc(key_memory_MYSQL_DATA, sizeof(MEM_ROOT),
                                    MYF(MY_WME | MY_ZEROFILL)))) {
      set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
      net_async->read_rows_is_first_read = true;
      free_rows(result);
      return NET_ASYNC_COMPLETE;
    }
    async_context->rows_result_buffer = result;
    init_alloc_root(PSI_NOT_INSTRUMENTED, result->alloc, 8192,
                    0); /* Assume rowlength < 8192 */
    async_context->prev_row_ptr = &result->data;
    result->rows = 0;
    result->fields = fields;

    net_async->read_rows_is_first_read = false;
  }

  /*
    The last EOF packet is either a single 254 character or (in MySQL 4.1)
    254 followed by 1-7 status bytes or an OK packet starting with 0xFE
  */
  while (*(cp = net->read_pos) == 0 || is_data_packet) {
    MYSQL_DATA *result = async_context->rows_result_buffer;
    result->rows++;
    if (!(cur = (MYSQL_ROWS *)result->alloc->Alloc(sizeof(MYSQL_ROWS))) ||
        !(cur->data = ((MYSQL_ROW)result->alloc->Alloc(
              (fields + 1) * sizeof(char *) + pkt_len)))) {
      free_rows(result);
      async_context->rows_result_buffer = nullptr;
      set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
      net_async->read_rows_is_first_read = true;
      return NET_ASYNC_COMPLETE;
    }
    *async_context->prev_row_ptr = cur;
    async_context->prev_row_ptr = &cur->next;
    to = (char *)(cur->data + fields + 1);
    end_to = to + pkt_len - 1;
    for (field = 0; field < fields; field++) {
      if ((len = (ulong)net_field_length(&cp)) ==
          NULL_LENGTH) { /* null field */
        cur->data[field] = nullptr;
      } else {
        cur->data[field] = to;
        if (to > end_to || len > (ulong)(end_to - to)) {
          free_rows(result);
          async_context->rows_result_buffer = nullptr;
          set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
          net_async->read_rows_is_first_read = true;
          return NET_ASYNC_COMPLETE;
        }
        memcpy(to, (char *)cp, len);
        to[len] = 0;
        to += len + 1;
        cp += len;
        if (mysql_fields) {
          if (mysql_fields[field].max_length < len)
            mysql_fields[field].max_length = len;
        }
      }
    }
    cur->data[field] = to; /* End of last field */
    if (cli_safe_read_nonblocking(mysql, &is_data_packet, &pkt_len) ==
        NET_ASYNC_NOT_READY) {
      return NET_ASYNC_NOT_READY;
    }
    mysql->packet_length = pkt_len;
    if (pkt_len == packet_error) {
      free_rows(async_context->rows_result_buffer);
      async_context->rows_result_buffer = nullptr;
      net_async->read_rows_is_first_read = true;
      return NET_ASYNC_COMPLETE;
    }
  }

  *async_context->prev_row_ptr = nullptr; /* last pointer is null */
  /* read EOF packet or OK packet if it is new client */
  if (pkt_len > 1) {
    if (mysql->server_capabilities & CLIENT_DEPRECATE_EOF && !is_data_packet)
      read_ok_ex(mysql, pkt_len);
    else {
      mysql->warning_count = uint2korr(cp + 1);
      mysql->server_status = uint2korr(cp + 3);
    }

    DBUG_PRINT("info", ("status: %u  warning_count:  %u", mysql->server_status,
                        mysql->warning_count));
  }

#if defined(CLIENT_PROTOCOL_TRACING)
  if (mysql->server_status & SERVER_MORE_RESULTS_EXISTS)
    MYSQL_TRACE_STAGE(mysql, WAIT_FOR_RESULT);
  else
    MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);
#endif
  DBUG_PRINT("exit",
             ("Got %lu rows", (ulong)async_context->rows_result_buffer->rows));
  *result_out = async_context->rows_result_buffer;
  async_context->rows_result_buffer = nullptr;
  net_async->read_rows_is_first_read = true;
  return NET_ASYNC_COMPLETE;
}

/* Read all rows (data) from server */

MYSQL_DATA *cli_read_rows(MYSQL *mysql, MYSQL_FIELD *mysql_fields,
                          unsigned int fields) {
  uint field;
  ulong pkt_len;
  ulong len;
  uchar *cp;
  char *to, *end_to;
  MYSQL_DATA *result;
  MYSQL_ROWS **prev_ptr, *cur;
  NET *net = &mysql->net;
  bool is_data_packet;
  DBUG_TRACE;

  if ((pkt_len = cli_safe_read(mysql, &is_data_packet)) == packet_error)
    return nullptr;

  if (pkt_len == 0) return nullptr;
  if (!(result =
            (MYSQL_DATA *)my_malloc(key_memory_MYSQL_DATA, sizeof(MYSQL_DATA),
                                    MYF(MY_WME | MY_ZEROFILL))) ||
      !(result->alloc =
            (MEM_ROOT *)my_malloc(key_memory_MYSQL_DATA, sizeof(MEM_ROOT),
                                  MYF(MY_WME | MY_ZEROFILL)))) {
    set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
    free_rows(result);
    return nullptr;
  }
  init_alloc_root(PSI_NOT_INSTRUMENTED, result->alloc, 8192,
                  0); /* Assume rowlength < 8192 */
  prev_ptr = &result->data;
  result->rows = 0;
  result->fields = fields;

  /*
    The last EOF packet is either a single 254 character or (in MySQL 4.1)
    254 followed by 1-7 status bytes or an OK packet starting with 0xFE
  */

  while (*(cp = net->read_pos) == 0 || is_data_packet) {
    result->rows++;
    if (!(cur = (MYSQL_ROWS *)result->alloc->Alloc(sizeof(MYSQL_ROWS))) ||
        !(cur->data = ((MYSQL_ROW)result->alloc->Alloc(
              (fields + 1) * sizeof(char *) + pkt_len)))) {
      free_rows(result);
      set_mysql_error(mysql, CR_OUT_OF_MEMORY, unknown_sqlstate);
      return nullptr;
    }
    *prev_ptr = cur;
    prev_ptr = &cur->next;
    to = (char *)(cur->data + fields + 1);
    end_to = to + pkt_len - 1;
    for (field = 0; field < fields; field++) {
      if ((len = (ulong)net_field_length(&cp)) ==
          NULL_LENGTH) { /* null field */
        cur->data[field] = nullptr;
      } else {
        cur->data[field] = to;
        DBUG_EXECUTE_IF("simulate_invalid_packet_data", {
          to = end_to + 1;
          len = ULONG_MAX - 1;
        });
        if (to > end_to || len > (ulong)(end_to - to)) {
          free_rows(result);
          set_mysql_error(mysql, CR_MALFORMED_PACKET, unknown_sqlstate);
          return nullptr;
        }
        memcpy(to, (char *)cp, len);
        to[len] = 0;
        to += len + 1;
        cp += len;
        if (mysql_fields) {
          if (mysql_fields[field].max_length < len)
            mysql_fields[field].max_length = len;
        }
      }
    }
    cur->data[field] = to; /* End of last field */
    if ((pkt_len = cli_safe_read(mysql, &is_data_packet)) == packet_error) {
      free_rows(result);
      return nullptr;
    }
  }
  *prev_ptr = nullptr; /* last pointer is null */
  /* read EOF packet or OK packet if it is new client */
  if (pkt_len > 1) {
    if (mysql->server_capabilities & CLIENT_DEPRECATE_EOF && !is_data_packet)
      read_ok_ex(mysql, pkt_len);
    else {
      mysql->warning_count = uint2korr(cp + 1);
      mysql->server_status = uint2korr(cp + 3);
    }

    DBUG_PRINT("info", ("status: %u  warning_count:  %u", mysql->server_status,
                        mysql->warning_count));
  }

#if defined(CLIENT_PROTOCOL_TRACING)
  if (mysql->server_status & SERVER_MORE_RESULTS_EXISTS)
    MYSQL_TRACE_STAGE(mysql, WAIT_FOR_RESULT);
  else
    MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);
#endif
  DBUG_PRINT("exit", ("Got %lu rows", (ulong)result->rows));
  return result;
}

static int read_one_row_complete(MYSQL *mysql, ulong pkt_len,
                                 bool is_data_packet, uint fields,
                                 MYSQL_ROW row, ulong *lengths) {
  DBUG_TRACE;
  uint field;
  ulong len;
  uchar *pos, *prev_pos, *end_pos;
  NET *net = &mysql->net;

  if (net->read_pos[0] != 0x00 && !is_data_packet) {
    if (pkt_len > 1) /* MySQL 4.1 protocol */
    {
      if (mysql->server_capabilities & CLIENT_DEPRECATE_EOF)
        read_ok_ex(mysql, pkt_len);
      else {
        mysql->warning_count = uint2korr(net->read_pos + 1);
        mysql->server_status = uint2korr(net->read_pos + 3);
      }
    }
#if defined(CLIENT_PROTOCOL_TRACING)
    if (mysql->server_status & SERVER_MORE_RESULTS_EXISTS)
      MYSQL_TRACE_STAGE(mysql, WAIT_FOR_RESULT);
    else
      MYSQL_TRACE_STAGE(mysql, READY_FOR_COMMAND);
#endif
    return 1; /* End of data */
  }
  prev_pos = nullptr; /* allowed to write at packet[-1] */
  pos = net->read_pos;
  end_pos = pos + pkt_len;
  for (field = 0; field < fields; field++) {
    len = (ulong)net_field_length_checked(&pos, (ulong)(end_pos - pos));
    if (pos > end_pos) {
      set_mysql_error(mysql, CR_UNKNOWN_ERROR, unknown_sqlstate);
      return -1;
    }

    if (len == NULL_LENGTH) {
      row[field] = nullptr;
      *lengths++ = 0;
    } else {
      row[field] = (char *)pos;
      pos += len;
      *lengths++ = len;
    }
    if (prev_pos) *prev_pos = 0; /* Terminate prev field */
    prev_pos = pos;
  }
  row[field] = (char *)prev_pos + 1; /* End of last field */
  *prev_pos = 0;                     /* Terminate last field */
  return 0;
}

/*
  Read one row. Uses packet buffer as storage for fields.
  When next packet is read, the previous field values are destroyed
*/

static int read_one_row(MYSQL *mysql, uint fields, MYSQL_ROW row,
                        ulong *lengths) {
  ulong pkt_len;
  bool is_data_packet;

  if ((pkt_len = cli_safe_read(mysql, &is_data_packet)) == packet_error)
    return -1;

  return read_one_row_complete(mysql, pkt_len, is_data_packet, fields, row,
                               lengths);
}

static net_async_status read_one_row_nonblocking(MYSQL *mysql, uint fields,
                                                 MYSQL_ROW row, ulong *lengths,
                                                 int *res) {
  DBUG_TRACE;
  ulong pkt_len;
  bool is_data_packet;
  net_async_status status;

  status = cli_safe_read_nonblocking(mysql, &is_data_packet, &pkt_len);
  if (status == NET_ASYNC_NOT_READY) {
    return status;
  }

  mysql->packet_length = pkt_len;
  if (pkt_len == packet_error) {
    *res = -1;
    return NET_ASYNC_COMPLETE;
  }

  *res = read_one_row_complete(mysql, pkt_len, is_data_packet, fields, row,
                               lengths);
  return NET_ASYNC_COMPLETE;
}

/****************************************************************************
  Init MySQL structure or allocate one
****************************************************************************/


MYSQL *STDCALL mysql_init(MYSQL *mysql) {
  if (mysql_server_init(0, nullptr, nullptr)) return nullptr;
  if (!mysql) {
    if (!(mysql = (MYSQL *)my_malloc(key_memory_MYSQL, sizeof(*mysql),
                                     MYF(MY_WME | MY_ZEROFILL)))) {
      set_mysql_error(nullptr, CR_OUT_OF_MEMORY, unknown_sqlstate);
      return nullptr;
    }
    mysql->free_me = true;
  } else
    memset(mysql, 0, sizeof(*(mysql)));
  mysql->charset = default_client_charset_info;
  mysql->field_alloc = (MEM_ROOT *)my_malloc(
      key_memory_MYSQL, sizeof(*mysql->field_alloc), MYF(MY_WME | MY_ZEROFILL));
  if (!mysql->field_alloc) {
    set_mysql_error(nullptr, CR_OUT_OF_MEMORY, unknown_sqlstate);
    if (mysql->free_me) my_free(mysql);
    return nullptr;
  }
  my_stpcpy(mysql->net.sqlstate, not_error_sqlstate);

  /*
    Only enable LOAD DATA INFILE by default if configured with option
    ENABLED_LOCAL_INFILE
  */

#if defined(ENABLED_LOCAL_INFILE) && !defined(MYSQL_SERVER)
  mysql->options.client_flag |= CLIENT_LOCAL_FILES;
#endif

#if defined(_WIN32)
  mysql->options.shared_memory_base_name = (char *)def_shared_memory_base_name;
#endif

  mysql->options.report_data_truncation = true; /* default */

  /* Initialize extensions. */
  if (!(mysql->extension = mysql_extension_init(mysql))) {
    set_mysql_error(nullptr, CR_OUT_OF_MEMORY, unknown_sqlstate);
    return nullptr;
  }

  /*
    By default we don't reconnect because it could silently corrupt data (after
    reconnection you potentially lose table locks, user variables, session
    variables (transactions but they are specifically dealt with in
    mysql_reconnect()).
    This is a change: < 5.0.3 mysql->reconnect was set to 1 by default.
    How this change impacts existing apps:
    - existing apps which relyed on the default will see a behaviour change;
    they will have to set reconnect=1 after mysql_real_connect().
    - existing apps which explicitely asked for reconnection (the only way they
    could do it was by setting mysql.reconnect to 1 after mysql_real_connect())
    will not see a behaviour change.
    - existing apps which explicitely asked for no reconnection
    (mysql.reconnect=0) will not see a behaviour change.
  */
  mysql->reconnect = false;
#if !defined(MYSQL_SERVER)
  ENSURE_EXTENSIONS_PRESENT(&mysql->options);
  mysql->options.extension->ssl_mode = SSL_MODE_PREFERRED;
#endif
  /* by default connection_compressed should be OFF */
  ENSURE_EXTENSIONS_PRESENT(&mysql->options);
  mysql->options.extension->connection_compressed = false;

  mysql->resultset_metadata = RESULTSET_METADATA_FULL;
  ASYNC_DATA(mysql)->async_op_status = ASYNC_OP_UNSET;
  return mysql;
}

/*
  MYSQL::extension handling (see sql_common.h for declaration
  of MYSQL_EXTENSION structure).
*/

MYSQL_EXTENSION *mysql_extension_init(MYSQL *mysql MY_ATTRIBUTE((unused))) {
  MYSQL_EXTENSION *ext;

  ext = static_cast<MYSQL_EXTENSION *>(my_malloc(PSI_NOT_INSTRUMENTED,
                                                 sizeof(MYSQL_EXTENSION),
                                                 MYF(MY_WME | MY_ZEROFILL)));
  ext->mysql_async_context = static_cast<MYSQL_ASYNC *>(
      my_malloc(PSI_NOT_INSTRUMENTED, sizeof(struct MYSQL_ASYNC),
                MYF(MY_WME | MY_ZEROFILL)));
  /* set default value */
  ext->mysql_async_context->async_op_status = ASYNC_OP_UNSET;
#ifdef MYSQL_SERVER
  ext->server_extn = nullptr;
#endif
  return ext;
}

void mysql_extension_free(MYSQL_EXTENSION *ext) {
  if (!ext) return;
  if (ext->trace_data) my_free(ext->trace_data);
  if (ext->mysql_async_context) {
    if (ext->mysql_async_context->connect_context) {
      if (ext->mysql_async_context->connect_context
              ->scramble_buffer_allocated) {
        my_free(ext->mysql_async_context->connect_context->scramble_buffer);
        ext->mysql_async_context->connect_context->scramble_buffer = nullptr;
      }
      my_free(ext->mysql_async_context->connect_context);
      ext->mysql_async_context->connect_context = nullptr;
    }
    my_free(ext->mysql_async_context);
    ext->mysql_async_context = nullptr;
  }
  // free state change related resources.
  free_state_change_info(ext);

  my_free(ext);
}

/*
  Fill in SSL part of MYSQL structure and set 'use_ssl' flag.
  NB! Errors are not reported until you do mysql_real_connect.
*/

bool STDCALL mysql_ssl_set(MYSQL *mysql MY_ATTRIBUTE((unused)),
                           const char *key MY_ATTRIBUTE((unused)),
                           const char *cert MY_ATTRIBUTE((unused)),
                           const char *ca MY_ATTRIBUTE((unused)),
                           const char *capath MY_ATTRIBUTE((unused)),
                           const char *cipher MY_ATTRIBUTE((unused))) {
  bool result = false;
  DBUG_TRACE;
  result = mysql_options(mysql, MYSQL_OPT_SSL_KEY, key) +
                   mysql_options(mysql, MYSQL_OPT_SSL_CERT, cert) +
                   mysql_options(mysql, MYSQL_OPT_SSL_CA, ca) +
                   mysql_options(mysql, MYSQL_OPT_SSL_CAPATH, capath) +
                   mysql_options(mysql, MYSQL_OPT_SSL_CIPHER, cipher)
               ? true
               : false;
  return result;
}

/*
  Free strings in the SSL structure and clear 'use_ssl' flag.
  NB! Errors are not reported until you do mysql_real_connect.
*/

static void mysql_ssl_free(MYSQL *mysql) {
  DBUG_TRACE;

  my_free(mysql->options.ssl_key);
  my_free(mysql->options.ssl_cert);
  my_free(mysql->options.ssl_ca);
  my_free(mysql->options.ssl_capath);
  my_free(mysql->options.ssl_cipher);
  if (mysql->options.extension) {
    my_free(mysql->options.extension->tls_version);
    my_free(mysql->options.extension->ssl_crl);
    my_free(mysql->options.extension->ssl_crlpath);
    my_free(mysql->options.extension->tls_ciphersuites);
    my_free(mysql->options.extension->load_data_dir);
  }
  mysql->options.ssl_key = nullptr;
  mysql->options.ssl_cert = nullptr;
  mysql->options.ssl_ca = nullptr;
  mysql->options.ssl_capath = nullptr;
  mysql->options.ssl_cipher = nullptr;
  if (mysql->options.extension) {
    mysql->options.extension->ssl_crl = nullptr;
    mysql->options.extension->ssl_crlpath = nullptr;
    mysql->options.extension->ssl_ctx_flags = 0;
    mysql->options.extension->tls_version = nullptr;
    mysql->options.extension->ssl_mode = SSL_MODE_DISABLED;
    mysql->options.extension->ssl_fips_mode = SSL_FIPS_MODE_OFF;
    mysql->options.extension->tls_ciphersuites = nullptr;
    mysql->options.extension->load_data_dir = nullptr;
  }
  mysql->connector_fd = nullptr;
}

/*
  Return the SSL cipher (if any) used for current
  connection to the server.

  SYNOPSYS
    mysql_get_ssl_cipher()
      mysql pointer to the mysql connection

*/

const char *STDCALL mysql_get_ssl_cipher(MYSQL *mysql MY_ATTRIBUTE((unused))) {
  DBUG_TRACE;
  if (mysql->net.vio && mysql->net.vio->ssl_arg)
    return SSL_get_cipher_name((SSL *)mysql->net.vio->ssl_arg);
  return nullptr;
}

/*
  Check the server's (subject) Common Name against the
  hostname we connected to

  SYNOPSIS
  ssl_verify_server_cert()
    vio              pointer to a SSL connected vio
    server_hostname  name of the server that we connected to
    errptr           if we fail, we'll return (a pointer to a string
                     describing) the reason here

  RETURN VALUES
   0 Success
   1 Failed to validate server

 */

static int ssl_verify_server_cert(Vio *vio, const char *server_hostname,
                                  const char **errptr) {
  SSL *ssl;
  X509 *server_cert = nullptr;
  int ret_validation = 1;

#if !(OPENSSL_VERSION_NUMBER >= 0x10002000L)
  int cn_loc = -1;
  char *cn = NULL;
  ASN1_STRING *cn_asn1 = NULL;
  X509_NAME_ENTRY *cn_entry = NULL;
  X509_NAME *subject = NULL;
#endif

  DBUG_TRACE;
  DBUG_PRINT("enter", ("server_hostname: %s", server_hostname));

  if (!(ssl = (SSL *)vio->ssl_arg)) {
    *errptr = "No SSL pointer found";
    goto error;
  }

  if (!server_hostname) {
    *errptr = "No server hostname supplied";
    goto error;
  }

  if (!(server_cert = SSL_get_peer_certificate(ssl))) {
    *errptr = "Could not get server certificate";
    goto error;
  }

  if (X509_V_OK != SSL_get_verify_result(ssl)) {
    *errptr = "Failed to verify the server certificate";
    goto error;
  }
  /*
    We already know that the certificate exchanged was valid; the SSL library
    handled that. Now we need to verify that the contents of the certificate
    are what we expect.
  */

  /* Use OpenSSL certificate matching functions instead of our own if we
     have OpenSSL. The X509_check_* functions return 1 on success.
  */
#if OPENSSL_VERSION_NUMBER >= 0x10002000L
  /*
    For OpenSSL 1.0.2 and up we already set certificate verification
    parameters in the new_VioSSLFd() to perform automatic checks.
  */
  ret_validation = 0;
#else  /* OPENSSL_VERSION_NUMBER < 0x10002000L */
  /*
     OpenSSL prior to 1.0.2 do not support X509_check_host() function.
     Use deprecated X509_get_subject_name() instead.
  */
  subject = X509_get_subject_name((X509 *)server_cert);
  // Find the CN location in the subject
  cn_loc = X509_NAME_get_index_by_NID(subject, NID_commonName, -1);
  if (cn_loc < 0) {
    *errptr = "Failed to get CN location in the certificate subject";
    goto error;
  }

  // Get the CN entry for given location
  cn_entry = X509_NAME_get_entry(subject, cn_loc);
  if (cn_entry == NULL) {
    *errptr = "Failed to get CN entry using CN location";
    goto error;
  }

  // Get CN from common name entry
  cn_asn1 = X509_NAME_ENTRY_get_data(cn_entry);
  if (cn_asn1 == NULL) {
    *errptr = "Failed to get CN from CN entry";
    goto error;
  }

  cn = (char *)ASN1_STRING_data(cn_asn1);

  // There should not be any NULL embedded in the CN
  if ((size_t)ASN1_STRING_length(cn_asn1) != strlen(cn)) {
    *errptr = "NULL embedded in the certificate CN";
    goto error;
  }

  DBUG_PRINT("info", ("Server hostname in cert: %s", cn));
  if (!strcmp(cn, server_hostname)) {
    /* Success */
    ret_validation = 0;
  }
#endif /* OPENSSL_VERSION_NUMBER >= 0x10002000L */

  *errptr = "SSL certificate validation success";

error:
  if (server_cert != nullptr) X509_free(server_cert);
  return ret_validation;
}

/*
  Note that the mysql argument must be initialized with mysql_init()
  before calling mysql_real_connect !
*/

static bool cli_read_query_result(MYSQL *mysql);
static net_async_status cli_read_query_result_nonblocking(MYSQL *mysql);
static MYSQL_RES *cli_use_result(MYSQL *mysql);

int cli_read_change_user_result(MYSQL *mysql) {
  return cli_safe_read(mysql, nullptr);
}

net_async_status cli_read_change_user_result_nonblocking(MYSQL *mysql,
                                                         ulong *ret) {
  return cli_safe_read_nonblocking(mysql, nullptr, ret);
}

static MYSQL_METHODS client_methods = {
    cli_read_query_result,      /* read_query_result */
    cli_advanced_command,       /* advanced_command */
    cli_read_rows,              /* read_rows */
    cli_use_result,             /* use_result */
    cli_fetch_lengths,          /* fetch_lengths */
    cli_flush_use_result,       /* flush_use_result */
    cli_read_change_user_result /* read_change_user_result */
#ifndef MYSQL_SERVER
    ,
    cli_list_fields,         /* list_fields */
    cli_read_prepare_result, /* read_prepare_result */
    cli_stmt_execute,        /* stmt_execute */
    cli_read_binary_rows,    /* read_binary_rows */
    cli_unbuffered_fetch,    /* unbuffered_fetch */
    cli_read_statistics,     /* read_statistics */
    cli_read_query_result,   /* next_result */
    cli_read_binary_rows,    /* read_rows_from_cursor */
    free_rows
#endif
    ,
    cli_read_query_result_nonblocking,      /* read_query_result_nonblocking */
    cli_advanced_command_nonblocking,       /* advanced_command_nonblocking */
    cli_read_rows_nonblocking,              /* read_rows_nonblocking */
    cli_flush_use_result_nonblocking,       /* flush_use_result_nonblocking */
    cli_read_query_result_nonblocking,      /* next_result_nonblocking */
    cli_read_change_user_result_nonblocking /* read_change_user_result_nonblocking
                                             */
};

typedef enum my_cs_match_type_enum {
  /* MySQL and OS charsets are fully compatible */
  my_cs_exact,
  /* MySQL charset is very close to OS charset  */
  my_cs_approx,
  /*
    MySQL knows this charset, but it is not supported as client character set.
  */
  my_cs_unsupp
} my_cs_match_type;

struct MY_CSET_OS_NAME {
  const char *os_name;
  const char *my_name;
  my_cs_match_type param;
};

const MY_CSET_OS_NAME charsets[] = {
#ifdef _WIN32
    {"cp437", "cp850", my_cs_approx},     {"cp850", "cp850", my_cs_exact},
    {"cp852", "cp852", my_cs_exact},      {"cp858", "cp850", my_cs_approx},
    {"cp866", "cp866", my_cs_exact},      {"cp874", "tis620", my_cs_approx},
    {"cp932", "cp932", my_cs_exact},      {"cp936", "gbk", my_cs_approx},
    {"cp949", "euckr", my_cs_approx},     {"cp950", "big5", my_cs_exact},
    {"cp1200", "utf16le", my_cs_unsupp},  {"cp1201", "utf16", my_cs_unsupp},
    {"cp1250", "cp1250", my_cs_exact},    {"cp1251", "cp1251", my_cs_exact},
    {"cp1252", "latin1", my_cs_exact},    {"cp1253", "greek", my_cs_exact},
    {"cp1254", "latin5", my_cs_exact},    {"cp1255", "hebrew", my_cs_approx},
    {"cp1256", "cp1256", my_cs_exact},    {"cp1257", "cp1257", my_cs_exact},
    {"cp10000", "macroman", my_cs_exact}, {"cp10001", "sjis", my_cs_approx},
    {"cp10002", "big5", my_cs_approx},    {"cp10008", "gb2312", my_cs_approx},
    {"cp10021", "tis620", my_cs_approx},  {"cp10029", "macce", my_cs_exact},
    {"cp12001", "utf32", my_cs_unsupp},   {"cp20107", "swe7", my_cs_exact},
    {"cp20127", "latin1", my_cs_approx},  {"cp20866", "koi8r", my_cs_exact},
    {"cp20932", "ujis", my_cs_exact},     {"cp20936", "gb2312", my_cs_approx},
    {"cp20949", "euckr", my_cs_approx},   {"cp21866", "koi8u", my_cs_exact},
    {"cp28591", "latin1", my_cs_approx},  {"cp28592", "latin2", my_cs_exact},
    {"cp28597", "greek", my_cs_exact},    {"cp28598", "hebrew", my_cs_exact},
    {"cp28599", "latin5", my_cs_exact},   {"cp28603", "latin7", my_cs_exact},
    {"cp38598", "hebrew", my_cs_exact},   {"cp51932", "ujis", my_cs_exact},
    {"cp51936", "gb2312", my_cs_exact},   {"cp51949", "euckr", my_cs_exact},
    {"cp51950", "big5", my_cs_exact},     {"cp54936", "gb18030", my_cs_exact},
    {"cp65001", "utf8mb4", my_cs_exact},

#else /* not Windows */

    {"646", "latin1", my_cs_approx}, /* Default on Solaris */
    {"ANSI_X3.4-1968", "latin1", my_cs_approx},
    {"ansi1251", "cp1251", my_cs_exact},
    {"armscii8", "armscii8", my_cs_exact},
    {"armscii-8", "armscii8", my_cs_exact},
    {"ASCII", "latin1", my_cs_approx},
    {"Big5", "big5", my_cs_exact},
    {"cp1251", "cp1251", my_cs_exact},
    {"cp1255", "hebrew", my_cs_approx},
    {"CP866", "cp866", my_cs_exact},
    {"eucCN", "gb2312", my_cs_exact},
    {"euc-CN", "gb2312", my_cs_exact},
    {"eucJP", "ujis", my_cs_exact},
    {"euc-JP", "ujis", my_cs_exact},
    {"eucKR", "euckr", my_cs_exact},
    {"euc-KR", "euckr", my_cs_exact},
    {"gb18030", "gb18030", my_cs_exact},
    {"gb2312", "gb2312", my_cs_exact},
    {"gbk", "gbk", my_cs_exact},
    {"georgianps", "geostd8", my_cs_exact},
    {"georgian-ps", "geostd8", my_cs_exact},
    {"IBM-1252", "cp1252", my_cs_exact},

    {"iso88591", "latin1", my_cs_approx},
    {"ISO_8859-1", "latin1", my_cs_approx},
    {"ISO8859-1", "latin1", my_cs_approx},
    {"ISO-8859-1", "latin1", my_cs_approx},

    {"iso885913", "latin7", my_cs_exact},
    {"ISO_8859-13", "latin7", my_cs_exact},
    {"ISO8859-13", "latin7", my_cs_exact},
    {"ISO-8859-13", "latin7", my_cs_exact},

    {"iso88592", "latin2", my_cs_exact},
    {"ISO_8859-2", "latin2", my_cs_exact},
    {"ISO8859-2", "latin2", my_cs_exact},
    {"ISO-8859-2", "latin2", my_cs_exact},

    {"iso88597", "greek", my_cs_exact},
    {"ISO_8859-7", "greek", my_cs_exact},
    {"ISO8859-7", "greek", my_cs_exact},
    {"ISO-8859-7", "greek", my_cs_exact},

    {"iso88598", "hebrew", my_cs_exact},
    {"ISO_8859-8", "hebrew", my_cs_exact},
    {"ISO8859-8", "hebrew", my_cs_exact},
    {"ISO-8859-8", "hebrew", my_cs_exact},

    {"iso88599", "latin5", my_cs_exact},
    {"ISO_8859-9", "latin5", my_cs_exact},
    {"ISO8859-9", "latin5", my_cs_exact},
    {"ISO-8859-9", "latin5", my_cs_exact},

    {"koi8r", "koi8r", my_cs_exact},
    {"KOI8-R", "koi8r", my_cs_exact},
    {"koi8u", "koi8u", my_cs_exact},
    {"KOI8-U", "koi8u", my_cs_exact},

    {"roman8", "hp8", my_cs_exact}, /* Default on HP UX */

    {"Shift_JIS", "sjis", my_cs_exact},
    {"SJIS", "sjis", my_cs_exact},
    {"shiftjisx0213", "sjis", my_cs_exact},

    {"tis620", "tis620", my_cs_exact},
    {"tis-620", "tis620", my_cs_exact},

    {"ujis", "ujis", my_cs_exact},

    {"US-ASCII", "latin1", my_cs_approx},

    {"utf8", "utf8mb4", my_cs_exact},
    {"utf-8", "utf8mb4", my_cs_exact},
#endif
    {nullptr, nullptr, my_cs_exact}};

const char *my_os_charset_to_mysql_charset(const char *csname) {
  const MY_CSET_OS_NAME *csp;
  for (csp = charsets; csp->os_name; csp++) {
    if (!my_strcasecmp(&my_charset_latin1, csp->os_name, csname)) {
      switch (csp->param) {
        case my_cs_exact:
          return csp->my_name;

        case my_cs_approx:
          /*
            Maybe we should print a warning eventually:
            character set correspondence is not exact.
          */
          return csp->my_name;

        default:
          my_printf_error(ER_UNKNOWN_ERROR,
                          "OS character set '%s'"
                          " is not supported by MySQL client",
                          MYF(0), csp->my_name);
          goto def;
      }
    }
  }

  my_printf_error(ER_UNKNOWN_ERROR, "Unknown OS character set '%s'.", MYF(0),
                  csname);

def:
  csname = MYSQL_DEFAULT_CHARSET_NAME;
  my_printf_error(ER_UNKNOWN_ERROR,
                  "Switching to the default character set '%s'.", MYF(0),
                  csname);
  return csname;
}

#ifndef _WIN32
#include <stdlib.h> /* for getenv() */
#ifdef HAVE_LANGINFO_H
#include <langinfo.h>
#endif
#include <locale.h>
#endif /* _WIN32 */

static int mysql_autodetect_character_set(MYSQL *mysql) {
  const char *csname = MYSQL_DEFAULT_CHARSET_NAME;

#ifdef _WIN32
  char cpbuf[64];
  {
    snprintf(cpbuf, sizeof(cpbuf), "cp%d", (int)GetConsoleCP());
    csname = my_os_charset_to_mysql_charset(cpbuf);
  }
#elif defined(HAVE_NL_LANGINFO)
  {
    if (setlocale(LC_CTYPE, "") && (csname = nl_langinfo(CODESET)))
      csname = my_os_charset_to_mysql_charset(csname);
  }
#endif

  if (mysql->options.charset_name) my_free(mysql->options.charset_name);
  if (!(mysql->options.charset_name =
            my_strdup(key_memory_mysql_options, csname, MYF(MY_WME))))
    return 1;
  return 0;
}

static void mysql_set_character_set_with_default_collation(MYSQL *mysql) {
  const char *save = charsets_dir;
  if (mysql->options.charset_dir) {
#ifdef MYSQL_SERVER
    // Do not change charsets_dir, it is not thread safe.
    DBUG_ASSERT(false);
#else
    charsets_dir = mysql->options.charset_dir;
#endif
  }
  if ((mysql->charset = get_charset_by_csname(mysql->options.charset_name,
                                              MY_CS_PRIMARY, MYF(MY_WME)))) {
    /* Try to set compiled default collation when it's possible. */
    CHARSET_INFO *collation;
    if ((collation =
             get_charset_by_name(MYSQL_DEFAULT_COLLATION_NAME, MYF(MY_WME))) &&
        my_charset_same(mysql->charset, collation)) {
      mysql->charset = collation;
    } else {
      /*
        Default compiled collation not found, or is not applicable
        to the requested character set.
        Continue with the default collation of the character set.
      */
    }
  }
  charsets_dir = save;
}

int mysql_init_character_set(MYSQL *mysql) {
  /* Set character set */
  if (!mysql->options.charset_name) {
    if (!(mysql->options.charset_name =
              my_strdup(key_memory_mysql_options, MYSQL_DEFAULT_CHARSET_NAME,
                        MYF(MY_WME))))
      return 1;
  } else if (!strcmp(mysql->options.charset_name,
                     MYSQL_AUTODETECT_CHARSET_NAME) &&
             mysql_autodetect_character_set(mysql))
    return 1;

  mysql_set_character_set_with_default_collation(mysql);

  if (!mysql->charset) {
    if (mysql->options.charset_dir)
      set_mysql_extended_error(mysql, CR_CANT_READ_CHARSET, unknown_sqlstate,
                               ER_CLIENT(CR_CANT_READ_CHARSET),
                               mysql->options.charset_name,
                               mysql->options.charset_dir);
    else {
      char cs_dir_name[FN_REFLEN];
      get_charsets_dir(cs_dir_name);
      set_mysql_extended_error(mysql, CR_CANT_READ_CHARSET, unknown_sqlstate,
                               ER_CLIENT(CR_CANT_READ_CHARSET),
                               mysql->options.charset_name, cs_dir_name);
    }
    return 1;
  }
  return 0;
}

/*********** client side authentication support **************************/

static int client_mpvio_write_packet(MYSQL_PLUGIN_VIO *, const uchar *, int);
static net_async_status client_mpvio_write_packet_nonblocking(
    struct MYSQL_PLUGIN_VIO *, const uchar *, int, int *);
static int native_password_auth_client(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql);
static net_async_status native_password_auth_client_nonblocking(
    MYSQL_PLUGIN_VIO *vio, MYSQL *mysql, int *result);
static int clear_password_auth_client(MYSQL_PLUGIN_VIO *vio, MYSQL *mysql);

static auth_plugin_t native_password_client_plugin = {
    MYSQL_CLIENT_AUTHENTICATION_PLUGIN,
    MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION,
    native_password_plugin_name,
    MYSQL_CLIENT_PLUGIN_AUTHOR_ORACLE,
    "Native MySQL authentication",
    {1, 0, 0},
    "GPL",
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    native_password_auth_client,
    native_password_auth_client_nonblocking};

static auth_plugin_t clear_password_client_plugin = {
    MYSQL_CLIENT_AUTHENTICATION_PLUGIN,
    MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION,
    "mysql_clear_password",
    MYSQL_CLIENT_PLUGIN_AUTHOR_ORACLE,
    "Clear password authentication plugin",
    {0, 1, 0},
    "GPL",
    nullptr,
    nullptr,
    nullptr,
    nullptr,
    clear_password_auth_client,
    nullptr};

static auth_plugin_t sha256_password_client_plugin = {
    MYSQL_CLIENT_AUTHENTICATION_PLUGIN,
    MYSQL_CLIENT_AUTHENTICATION_PLUGIN_INTERFACE_VERSION,
    "sha256_password",
