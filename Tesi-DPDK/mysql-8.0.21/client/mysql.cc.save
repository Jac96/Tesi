/*
   Copyright (c) 2000, 2020, Oracle and/or its affiliates.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License, version 2.0,
   as published by the Free Software Foundation.

   This program is also distributed with certain software (including
   but not limited to OpenSSL) that is licensed under separate terms,
   as designated in a particular file or component or in included license
   documentation.  The authors of MySQL hereby grant you an additional
   permission to link the program and your derivative works with the
   separately licensed software that they have included with MySQL.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License, version 2.0, for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301  USA
*/

// mysql command tool

#include "my_config.h"

#include <errno.h>
#include <fcntl.h>
#include <inttypes.h>
#include <math.h>
#include <signal.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <time.h>

#include "client/client_priv.h"
#include "client/my_readline.h"
#include "client/pattern_matcher.h"
#include "compression.h"
#include "lex_string.h"
#include "m_ctype.h"
#include "my_compiler.h"
#include "my_dbug.h"
#include "my_default.h"
#include "my_dir.h"
#include "my_inttypes.h"
#include "my_io.h"
#include "my_loglevel.h"
#include "my_macros.h"
#include "typelib.h"
#include "violite.h"

//DPDK includes

#include <rte_eal.h>
#include <rte_errno.h>

#include <string.h>

#ifdef HAVE_SYS_IOCTL_H
#include <sys/ioctl.h>
#endif

#if defined(USE_LIBEDIT_INTERFACE)
#include <locale.h>
#endif

#ifdef HAVE_PWD_H
#include <pwd.h>
#endif

#if defined(HAVE_TERM_H)
#define NOMACROS  // move() macro interferes with std::move.
#include <curses.h>
#include <term.h>
#endif

#if defined(_WIN32)
#include <conio.h>

// Not using syslog but EventLog on Win32, so a dummy facility is enough.
#define LOG_USER 0
#else
#include <readline.h>
#include <syslog.h>

#define HAVE_READLINE
#define USE_POPEN
#endif

#include <mysqld_error.h>
#include <algorithm>
#include <new>

#include "sql_common.h"

#include "sql-common/net_ns.h"


using std::max;
using std::min;

extern CHARSET_INFO my_charset_utf16le_bin;

const char *VER = "14.14";

/* Don't try to make a nice table if the data is too big */
#define MAX_COLUMN_LENGTH 1024

/* Buffer to hold 'version' and 'version_comment' */
static char *server_version = nullptr;

/* Array of options to pass to libemysqld */
#define MAX_SERVER_ARGS 64

/* Maximum memory limit that can be claimed by alloca(). */
#define MAX_ALLOCA_SIZE 512

#include "sql_string.h"

#ifdef FN_NO_CASE_SENSE
#define cmp_database(cs, A, B) my_strcasecmp((cs), (A), (B))
#else
#define cmp_database(cs, A, B) strcmp((A), (B))
#endif

#include "client/completion_hash.h"
#include "print_version.h"
#include "welcome_copyright_notice.h"  // ORACLE_WELCOME_COPYRIGHT_NOTICE

#define PROMPT_CHAR '\\'
#define DEFAULT_DELIMITER ";"

#define MAX_BATCH_BUFFER_SIZE (1024L * 1024L * 1024L)

/** default set of patterns used for history exclusion filter */
const static std::string HI_DEFAULTS("*IDENTIFIED*:*PASSWORD*");

/** used for matching which history lines to ignore */
static Pattern_matcher ignore_matcher;

struct STATUS {
  int exit_status;
  ulong query_start_line;
  char *file_name;
  LINE_BUFFER *line_buff;
  bool batch, add_to_history;
};

static HashTable ht;
static MEM_ROOT argv_alloc{PSI_NOT_INSTRUMENTED, 512};

enum enum_info_type { INFO_INFO, INFO_ERROR, INFO_RESULT };
typedef enum enum_info_type INFO_TYPE;

static MYSQL mysql; /* The connection */
static bool ignore_errors = false, wait_flag = false, quick = false,
            connected = false, opt_raw_data = false, unbuffered = false,
            output_tables = false, opt_rehash = true, skip_updates = false,
            safe_updates = false, one_database = false, opt_compress = false,
            using_opt_local_infile = false, vertical = false,
            line_numbers = true, column_names = true, opt_html = false,
            opt_xml = false, opt_nopager = true, opt_outfile = false,
            named_cmds = false, tty_password = false, opt_nobeep = false,
            opt_reconnect = true, default_pager_set = false,
            opt_sigint_ignore = false, auto_vertical_output = false,
            show_warnings = false, executing_query = false,
            interrupted_query = false, ignore_spaces = false,
            sigint_received = false, opt_syslog = false, opt_binhex = false;
static bool opt_binary_as_hex_set_explicitly = false;
static bool debug_info_flag, debug_check_flag;
static bool column_types_flag;
static bool preserve_comments = false;
static ulong opt_max_allowed_packet, opt_net_buffer_length;
static uint verbose = 0, opt_silent = 0, opt_mysql_port = 0,
            opt_local_infile = 0;
static uint opt_enable_cleartext_plugin = 0;
static bool using_opt_enable_cleartext_plugin = false;
static uint my_end_arg;
static char *opt_mysql_unix_port = nullptr;
static char *opt_bind_addr = nullptr;
static int connect_flag = CLIENT_INTERACTIVE;
static bool opt_binary_mode = false;
static bool opt_connect_expired_password = false;
static char *current_host;
static char *current_db;
static char *current_user = nullptr;
static char *opt_password = nullptr;
static char *current_prompt = nullptr;
static char *delimiter_str = nullptr;
static char *opt_init_command = nullptr;
static const char *default_charset = MYSQL_AUTODETECT_CHARSET_NAME;
static char *histfile;
static char *histfile_tmp;
static char *opt_histignore = nullptr;
static String glob_buffer, old_buffer;
static String processed_prompt;
static char *full_username = nullptr, *part_username = nullptr,
            *default_prompt = nullptr;
static char *current_os_user = nullptr, *current_os_sudouser = nullptr;
static int wait_time = 5;
static STATUS status;
static ulong select_limit, max_join_size, opt_connect_timeout = 0;
static char mysql_charsets_dir[FN_REFLEN + 1];
static char *opt_plugin_dir = nullptr, *opt_default_auth = nullptr;
static char *opt_load_data_local_dir = nullptr;
#ifdef HAVE_SETNS
static char *opt_network_namespace = nullptr;
#endif
static const char *xmlmeta[] = {
    "&", "&amp;", "<", "&lt;", ">", "&gt;", "\"", "&quot;",
    /* Turn \0 into a space. Why not &#0;? That's not valid XML or HTML. */
    "\0", " ", nullptr, nullptr};
static const char *day_names[] = {"Sun", "Mon", "Tue", "Wed",
                                  "Thu", "Fri", "Sat"};
static const char *month_names[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                                    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
static char default_pager[FN_REFLEN];
static char pager[FN_REFLEN], outfile[FN_REFLEN];
static FILE *PAGER, *OUTFILE;
static MEM_ROOT hash_mem_root;
static uint prompt_counter;
static char delimiter[16] = DEFAULT_DELIMITER;
static size_t delimiter_length = 1;
unsigned short terminal_width = 80;
static uint opt_zstd_compress_level = default_zstd_compression_level;
static char *opt_compress_algorithm = nullptr;

#if defined(_WIN32)
static char *shared_memory_base_name = 0;
#endif
static uint opt_protocol = 0;
static const CHARSET_INFO *charset_info = &my_charset_latin1;

#include "caching_sha2_passwordopt-vars.h"
#include "sslopt-vars.h"

const char *default_dbug_option = "d:t:o,/tmp/mysql.trace";

/*
  completion_hash is an auxiliary feature for mysql client to complete
  an object name(db name, table name and field name) automatically.
  e.g.
  mysql> use my_d
  then press <TAB>, it will check the hash and complete the db name
  for users.
  the result will be:
  mysql> use my_dbname

  In general, this feature is only on when it is an interactive mysql client.
  It is not possible to use it in test case.

  For using this feature in test case, we add the option in debug code.
*/
#ifndef DBUG_OFF
static bool opt_build_completion_hash = false;
#endif

#ifdef _WIN32
/*
  A flag that indicates if --execute buffer has already been converted,
  to avoid double conversion on reconnect.
*/
static bool execute_buffer_conversion_done{false};

/*
  my_win_is_console(...) is quite slow.
  We cache my_win_is_console() results for stdout and stderr.
  Any other output files, except stdout and stderr,
  cannot be Windows console.
  Note, if mysql.exe is executed from a service, its _fileno(stdout) is -1,
  so shift (1 << -1) can return implementation defined result.
  This corner case is taken into account, as the shift result
  will be multiplied to 0 and we'll get 0 as a result.
  The same is true for stderr.
*/
static uint win_is_console_cache =
    ((my_win_is_console(stdout)) * (1 << _fileno(stdout))) |
    ((my_win_is_console(stderr)) * (1 << _fileno(stderr)));

static inline bool my_win_is_console_cached(FILE *file) {
  return win_is_console_cache & (1 << _fileno(file));
}
#endif /* _WIN32 */

/* Various printing flags */
#define MY_PRINT_ESC_0 1 /* Replace 0x00 bytes to "\0"              */
#define MY_PRINT_SPS_0 2 /* Replace 0x00 bytes to space             */
#define MY_PRINT_XML 4   /* Encode XML entities                     */
#define MY_PRINT_MB 8    /* Recognize multi-byte characters         */
#define MY_PRINT_CTRL 16 /* Replace TAB, NL, CR to "\t", "\n", "\r" */

void tee_write(FILE *file, const char *s, size_t slen, int flags);
void tee_fprintf(FILE *file, const char *fmt, ...)
    MY_ATTRIBUTE((format(printf, 2, 3)));
void tee_fputs(const char *s, FILE *file);
void tee_puts(const char *s, FILE *file);
void tee_putc(int c, FILE *file);
static void tee_print_sized_data(const char *, unsigned int, unsigned int,
                                 bool);
/* The names of functions that actually do the manipulation. */
static int get_options(int argc, char **argv);
extern "C" bool get_one_option(int optid, const struct my_option *opt,
                               char *argument);
static int com_quit(String *str, char *), com_go(String *str, char *),
    com_ego(String *str, char *), com_print(String *str, char *),
    com_help(String *str, char *), com_clear(String *str, char *),
    com_connect(String *str, char *), com_status(String *str, char *),
    com_use(String *str, char *), com_source(String *str, char *),
    com_rehash(String *str, char *), com_tee(String *str, char *),
    com_notee(String *str, char *), com_charset(String *str, char *),
    com_prompt(String *str, char *), com_delimiter(String *str, char *),
    com_warnings(String *str, char *), com_nowarnings(String *str, char *),
    com_resetconnection(String *str, char *);
static int com_shell(String *str, char *);

#ifdef USE_POPEN
static int com_nopager(String *str, char *), com_pager(String *str, char *),
    com_edit(String *str, char *);
#endif

static int read_and_execute(bool interactive);
static bool init_connection_options(MYSQL *mysql);
static int sql_connect(char *host, char *database, char *user, char *password,
                       uint silent);
static const char *server_version_string(MYSQL *mysql);
static int put_info(const char *str, INFO_TYPE info, uint error = 0,
                    const char *sql_state = nullptr);
static int put_error(MYSQL *mysql);
static void safe_put_field(const char *pos, ulong length);
static void xmlencode_print(const char *src, uint length);
static void init_pager();
static void end_pager();
static void init_tee(const char *);
static void end_tee();
static const char *construct_prompt();
static inline void reset_prompt(char *in_string, bool *ml_comment);
static char *get_arg(char *line, bool get_next_arg);
static void init_username();
static void add_int_to_prompt(int toadd);
static int get_result_width(MYSQL_RES *res);
static int get_field_disp_length(MYSQL_FIELD *field);
static int normalize_dbname(const char *line, char *buff, uint buff_size);
static int get_quote_count(const char *line);

static void add_filtered_history(const char *string);
static void add_syslog(const char *buffer); /* for syslog */
static void fix_line(String *buffer);

static void get_current_os_user();
static void get_current_os_sudouser();

/* A structure which contains information on the commands this program
   can understand. */

typedef struct {
  const char *name;                 /* User printable name of the function. */
  char cmd_char;                    /* msql command character */
  int (*func)(String *str, char *); /* Function to call to do the job. */
  bool takes_params;                /* Max parameters for command */
  const char *doc;                  /* Documentation for this function.  */
} COMMANDS;

static COMMANDS commands[] = {
    {"?", '?', com_help, true, "Synonym for `help'."},
    {"clear", 'c', com_clear, false, "Clear the current input statement."},
    {"connect", 'r', com_connect, true,
     "Reconnect to the server. Optional arguments are db and host."},
    {"delimiter", 'd', com_delimiter, true, "Set statement delimiter."},
#ifdef USE_POPEN
    {"edit", 'e', com_edit, false, "Edit command with $EDITOR."},
#endif
    {"ego", 'G', com_ego, false,
     "Send command to mysql server, display result vertically."},
    {"exit", 'q', com_quit, false, "Exit mysql. Same as quit."},
    {"go", 'g', com_go, false, "Send command to mysql server."},
    {"help", 'h', com_help, true, "Display this help."},
#ifdef USE_POPEN
    {"nopager", 'n', com_nopager, false, "Disable pager, print to stdout."},
#endif
    {"notee", 't', com_notee, false, "Don't write into outfile."},
#ifdef USE_POPEN
    {"pager", 'P', com_pager, true,
     "Set PAGER [to_pager]. Print the query results via PAGER."},
#endif
    {"print", 'p', com_print, false, "Print current command."},
    {"prompt", 'R', com_prompt, true, "Change your mysql prompt."},
    {"quit", 'q', com_quit, false, "Quit mysql."},
    {"rehash", '#', com_rehash, false, "Rebuild completion hash."},
    {"source", '.', com_source, true,
     "Execute an SQL script file. Takes a file name as an argument."},
    {"status", 's', com_status, false,
     "Get status information from the server."},
    {"system", '!', com_shell, true, "Execute a system shell command."},
    {"tee", 'T', com_tee, true,
     "Set outfile [to_outfile]. Append everything into given outfile."},
    {"use", 'u', com_use, true,
     "Use another database. Takes database name as argument."},
    {"charset", 'C', com_charset, true,
     "Switch to another charset. Might be needed for processing binlog with "
     "multi-byte charsets."},
    {"warnings", 'W', com_warnings, false,
     "Show warnings after every statement."},
    {"nowarning", 'w', com_nowarnings, false,
     "Don't show warnings after every statement."},
    {"resetconnection", 'x', com_resetconnection, false,
     "Clean session context."},
    /* Get bash-like expansion for some commands */
    {"create table", 0, nullptr, false, ""},
    {"create database", 0, nullptr, false, ""},
    {"show databases", 0, nullptr, false, ""},
    {"show fields from", 0, nullptr, false, ""},
    {"show keys from", 0, nullptr, false, ""},
    {"show tables", 0, nullptr, false, ""},
    {"load data from", 0, nullptr, false, ""},
    {"alter table", 0, nullptr, false, ""},
    {"set option", 0, nullptr, false, ""},
    {"lock tables", 0, nullptr, false, ""},
    {"unlock tables", 0, nullptr, false, ""},
    /* generated 2006-12-28.  Refresh occasionally from lexer. */
    {"ACTION", 0, nullptr, false, ""},
    {"ADD", 0, nullptr, false, ""},
    {"AFTER", 0, nullptr, false, ""},
    {"AGAINST", 0, nullptr, false, ""},
    {"AGGREGATE", 0, nullptr, false, ""},
    {"ALL", 0, nullptr, false, ""},
    {"ALGORITHM", 0, nullptr, false, ""},
    {"ALTER", 0, nullptr, false, ""},
    {"ANALYZE", 0, nullptr, false, ""},
    {"AND", 0, nullptr, false, ""},
    {"ANY", 0, nullptr, false, ""},
    {"AS", 0, nullptr, false, ""},
    {"ASC", 0, nullptr, false, ""},
    {"ASCII", 0, nullptr, false, ""},
    {"ASENSITIVE", 0, nullptr, false, ""},
    {"AUTO_INCREMENT", 0, nullptr, false, ""},
    {"AVG", 0, nullptr, false, ""},
    {"AVG_ROW_LENGTH", 0, nullptr, false, ""},
    {"BACKUP", 0, nullptr, false, ""},
    {"BDB", 0, nullptr, false, ""},
    {"BEFORE", 0, nullptr, false, ""},
    {"BEGIN", 0, nullptr, false, ""},
    {"BERKELEYDB", 0, nullptr, false, ""},
    {"BETWEEN", 0, nullptr, false, ""},
    {"BIGINT", 0, nullptr, false, ""},
    {"BINARY", 0, nullptr, false, ""},
    {"BINLOG", 0, nullptr, false, ""},
    {"BIT", 0, nullptr, false, ""},
    {"BLOB", 0, nullptr, false, ""},
    {"BOOL", 0, nullptr, false, ""},
    {"BOOLEAN", 0, nullptr, false, ""},
    {"BOTH", 0, nullptr, false, ""},
    {"BTREE", 0, nullptr, false, ""},
    {"BY", 0, nullptr, false, ""},
    {"BYTE", 0, nullptr, false, ""},
    {"CACHE", 0, nullptr, false, ""},
    {"CALL", 0, nullptr, false, ""},
    {"CASCADE", 0, nullptr, false, ""},
    {"CASCADED", 0, nullptr, false, ""},
    {"CASE", 0, nullptr, false, ""},
    {"CHAIN", 0, nullptr, false, ""},
    {"CHANGE", 0, nullptr, false, ""},
    {"CHANGED", 0, nullptr, false, ""},
    {"CHAR", 0, nullptr, false, ""},
    {"CHARACTER", 0, nullptr, false, ""},
    {"CHARSET", 0, nullptr, false, ""},
    {"CHECK", 0, nullptr, false, ""},
    {"CHECKSUM", 0, nullptr, false, ""},
    {"CIPHER", 0, nullptr, false, ""},
    {"CLIENT", 0, nullptr, false, ""},
    {"CLOSE", 0, nullptr, false, ""},
    {"CODE", 0, nullptr, false, ""},
    {"COLLATE", 0, nullptr, false, ""},
    {"COLLATION", 0, nullptr, false, ""},
    {"COLUMN", 0, nullptr, false, ""},
    {"COLUMNS", 0, nullptr, false, ""},
    {"COMMENT", 0, nullptr, false, ""},
    {"COMMIT", 0, nullptr, false, ""},
    {"COMMITTED", 0, nullptr, false, ""},
    {"COMPACT", 0, nullptr, false, ""},
    {"COMPRESSED", 0, nullptr, false, ""},
    {"CONCURRENT", 0, nullptr, false, ""},
    {"CONDITION", 0, nullptr, false, ""},
    {"CONNECTION", 0, nullptr, false, ""},
    {"CONSISTENT", 0, nullptr, false, ""},
    {"CONSTRAINT", 0, nullptr, false, ""},
    {"CONTAINS", 0, nullptr, false, ""},
    {"CONTINUE", 0, nullptr, false, ""},
    {"CONVERT", 0, nullptr, false, ""},
    {"CREATE", 0, nullptr, false, ""},
    {"CROSS", 0, nullptr, false, ""},
    {"CUBE", 0, nullptr, false, ""},
    {"CURRENT_DATE", 0, nullptr, false, ""},
    {"CURRENT_TIME", 0, nullptr, false, ""},
    {"CURRENT_TIMESTAMP", 0, nullptr, false, ""},
    {"CURRENT_USER", 0, nullptr, false, ""},
    {"CURSOR", 0, nullptr, false, ""},
    {"DATA", 0, nullptr, false, ""},
    {"DATABASE", 0, nullptr, false, ""},
    {"DATABASES", 0, nullptr, false, ""},
    {"DATE", 0, nullptr, false, ""},
    {"DATETIME", 0, nullptr, false, ""},
    {"DAY", 0, nullptr, false, ""},
    {"DAY_HOUR", 0, nullptr, false, ""},
    {"DAY_MICROSECOND", 0, nullptr, false, ""},
    {"DAY_MINUTE", 0, nullptr, false, ""},
    {"DAY_SECOND", 0, nullptr, false, ""},
    {"DEALLOCATE", 0, nullptr, false, ""},
    {"DEC", 0, nullptr, false, ""},
    {"DECIMAL", 0, nullptr, false, ""},
    {"DECLARE", 0, nullptr, false, ""},
    {"DEFAULT", 0, nullptr, false, ""},
    {"DEFINER", 0, nullptr, false, ""},
    {"DELAYED", 0, nullptr, false, ""},
    {"DELAY_KEY_WRITE", 0, nullptr, false, ""},
    {"DELETE", 0, nullptr, false, ""},
    {"DESC", 0, nullptr, false, ""},
    {"DESCRIBE", 0, nullptr, false, ""},
    {"DETERMINISTIC", 0, nullptr, false, ""},
    {"DIRECTORY", 0, nullptr, false, ""},
    {"DISABLE", 0, nullptr, false, ""},
    {"DISCARD", 0, nullptr, false, ""},
    {"DISTINCT", 0, nullptr, false, ""},
    {"DISTINCTROW", 0, nullptr, false, ""},
    {"DIV", 0, nullptr, false, ""},
    {"DO", 0, nullptr, false, ""},
    {"DOUBLE", 0, nullptr, false, ""},
    {"DROP", 0, nullptr, false, ""},
    {"DUAL", 0, nullptr, false, ""},
    {"DUMPFILE", 0, nullptr, false, ""},
    {"DUPLICATE", 0, nullptr, false, ""},
    {"DYNAMIC", 0, nullptr, false, ""},
    {"EACH", 0, nullptr, false, ""},
    {"ELSE", 0, nullptr, false, ""},
    {"ELSEIF", 0, nullptr, false, ""},
    {"ENABLE", 0, nullptr, false, ""},
    {"ENCLOSED", 0, nullptr, false, ""},
    {"END", 0, nullptr, false, ""},
    {"ENGINE", 0, nullptr, false, ""},
    {"ENGINES", 0, nullptr, false, ""},
    {"ENUM", 0, nullptr, false, ""},
    {"ERRORS", 0, nullptr, false, ""},
    {"ESCAPE", 0, nullptr, false, ""},
    {"ESCAPED", 0, nullptr, false, ""},
    {"EVENTS", 0, nullptr, false, ""},
    {"EXECUTE", 0, nullptr, false, ""},
    {"EXISTS", 0, nullptr, false, ""},
    {"EXIT", 0, nullptr, false, ""},
    {"EXPANSION", 0, nullptr, false, ""},
    {"EXPLAIN", 0, nullptr, false, ""},
    {"EXTENDED", 0, nullptr, false, ""},
    {"FALSE", 0, nullptr, false, ""},
    {"FAST", 0, nullptr, false, ""},
    {"FETCH", 0, nullptr, false, ""},
    {"FIELDS", 0, nullptr, false, ""},
    {"FILE", 0, nullptr, false, ""},
    {"FIRST", 0, nullptr, false, ""},
    {"FIXED", 0, nullptr, false, ""},
    {"FLOAT", 0, nullptr, false, ""},
    {"FLOAT4", 0, nullptr, false, ""},
    {"FLOAT8", 0, nullptr, false, ""},
    {"FLUSH", 0, nullptr, false, ""},
    {"FOR", 0, nullptr, false, ""},
    {"FORCE", 0, nullptr, false, ""},
    {"FOREIGN", 0, nullptr, false, ""},
    {"FOUND", 0, nullptr, false, ""},
    {"FROM", 0, nullptr, false, ""},
    {"FULL", 0, nullptr, false, ""},
    {"FULLTEXT", 0, nullptr, false, ""},
    {"FUNCTION", 0, nullptr, false, ""},
    {"GEOMETRY", 0, nullptr, false, ""},
    {"GEOMETRYCOLLECTION", 0, nullptr, false, ""},
    {"GET_FORMAT", 0, nullptr, false, ""},
    {"GLOBAL", 0, nullptr, false, ""},
    {"GRANT", 0, nullptr, false, ""},
    {"GRANTS", 0, nullptr, false, ""},
    {"GROUP", 0, nullptr, false, ""},
    {"HANDLER", 0, nullptr, false, ""},
    {"HASH", 0, nullptr, false, ""},
    {"HAVING", 0, nullptr, false, ""},
    {"HELP", 0, nullptr, false, ""},
    {"HIGH_PRIORITY", 0, nullptr, false, ""},
    {"HOSTS", 0, nullptr, false, ""},
    {"HOUR", 0, nullptr, false, ""},
    {"HOUR_MICROSECOND", 0, nullptr, false, ""},
    {"HOUR_MINUTE", 0, nullptr, false, ""},
    {"HOUR_SECOND", 0, nullptr, false, ""},
    {"IDENTIFIED", 0, nullptr, false, ""},
    {"IF", 0, nullptr, false, ""},
    {"IGNORE", 0, nullptr, false, ""},
    {"IMPORT", 0, nullptr, false, ""},
    {"IN", 0, nullptr, false, ""},
    {"INDEX", 0, nullptr, false, ""},
    {"INDEXES", 0, nullptr, false, ""},
    {"INFILE", 0, nullptr, false, ""},
    {"INNER", 0, nullptr, false, ""},
    {"INNOBASE", 0, nullptr, false, ""},
    {"INNODB", 0, nullptr, false, ""},
    {"INOUT", 0, nullptr, false, ""},
    {"INSENSITIVE", 0, nullptr, false, ""},
    {"INSERT", 0, nullptr, false, ""},
    {"INSERT_METHOD", 0, nullptr, false, ""},
    {"INT", 0, nullptr, false, ""},
    {"INT1", 0, nullptr, false, ""},
    {"INT2", 0, nullptr, false, ""},
    {"INT3", 0, nullptr, false, ""},
    {"INT4", 0, nullptr, false, ""},
    {"INT8", 0, nullptr, false, ""},
    {"INTEGER", 0, nullptr, false, ""},
    {"INTERVAL", 0, nullptr, false, ""},
    {"INTO", 0, nullptr, false, ""},
    {"IO_THREAD", 0, nullptr, false, ""},
    {"IS", 0, nullptr, false, ""},
    {"ISOLATION", 0, nullptr, false, ""},
    {"ISSUER", 0, nullptr, false, ""},
    {"ITERATE", 0, nullptr, false, ""},
    {"INVOKER", 0, nullptr, false, ""},
    {"JOIN", 0, nullptr, false, ""},
    {"KEY", 0, nullptr, false, ""},
    {"KEYS", 0, nullptr, false, ""},
    {"KILL", 0, nullptr, false, ""},
    {"LANGUAGE", 0, nullptr, false, ""},
    {"LAST", 0, nullptr, false, ""},
    {"LEADING", 0, nullptr, false, ""},
    {"LEAVE", 0, nullptr, false, ""},
    {"LEAVES", 0, nullptr, false, ""},
    {"LEFT", 0, nullptr, false, ""},
    {"LEVEL", 0, nullptr, false, ""},
    {"LIKE", 0, nullptr, false, ""},
    {"LIMIT", 0, nullptr, false, ""},
    {"LINES", 0, nullptr, false, ""},
    {"LINESTRING", 0, nullptr, false, ""},
    {"LOAD", 0, nullptr, false, ""},
    {"LOCAL", 0, nullptr, false, ""},
    {"LOCALTIME", 0, nullptr, false, ""},
    {"LOCALTIMESTAMP", 0, nullptr, false, ""},
    {"LOCK", 0, nullptr, false, ""},
    {"LOCKS", 0, nullptr, false, ""},
    {"LOGS", 0, nullptr, false, ""},
    {"LONG", 0, nullptr, false, ""},
    {"LONGBLOB", 0, nullptr, false, ""},
    {"LONGTEXT", 0, nullptr, false, ""},
    {"LOOP", 0, nullptr, false, ""},
    {"LOW_PRIORITY", 0, nullptr, false, ""},
    {"MASTER", 0, nullptr, false, ""},
    {"MASTER_CONNECT_RETRY", 0, nullptr, false, ""},
    {"MASTER_HOST", 0, nullptr, false, ""},
    {"MASTER_LOG_FILE", 0, nullptr, false, ""},
    {"MASTER_LOG_POS", 0, nullptr, false, ""},
    {"MASTER_PASSWORD", 0, nullptr, false, ""},
    {"MASTER_PORT", 0, nullptr, false, ""},
    {"MASTER_SERVER_ID", 0, nullptr, false, ""},
    {"MASTER_SSL", 0, nullptr, false, ""},
    {"MASTER_SSL_CA", 0, nullptr, false, ""},
    {"MASTER_SSL_CAPATH", 0, nullptr, false, ""},
    {"MASTER_SSL_CERT", 0, nullptr, false, ""},
    {"MASTER_SSL_CIPHER", 0, nullptr, false, ""},
    {"MASTER_TLS_VERSION", 0, nullptr, false, ""},
    {"MASTER_SSL_KEY", 0, nullptr, false, ""},
    {"MASTER_USER", 0, nullptr, false, ""},
    {"MATCH", 0, nullptr, false, ""},
    {"MAX_CONNECTIONS_PER_HOUR", 0, nullptr, false, ""},
    {"MAX_QUERIES_PER_HOUR", 0, nullptr, false, ""},
    {"MAX_ROWS", 0, nullptr, false, ""},
    {"MAX_UPDATES_PER_HOUR", 0, nullptr, false, ""},
    {"MAX_USER_CONNECTIONS", 0, nullptr, false, ""},
    {"MEDIUM", 0, nullptr, false, ""},
    {"MEDIUMBLOB", 0, nullptr, false, ""},
    {"MEDIUMINT", 0, nullptr, false, ""},
    {"MEDIUMTEXT", 0, nullptr, false, ""},
    {"MERGE", 0, nullptr, false, ""},
    {"MICROSECOND", 0, nullptr, false, ""},
    {"MIDDLEINT", 0, nullptr, false, ""},
    {"MIGRATE", 0, nullptr, false, ""},
    {"MINUTE", 0, nullptr, false, ""},
    {"MINUTE_MICROSECOND", 0, nullptr, false, ""},
    {"MINUTE_SECOND", 0, nullptr, false, ""},
    {"MIN_ROWS", 0, nullptr, false, ""},
    {"MOD", 0, nullptr, false, ""},
    {"MODE", 0, nullptr, false, ""},
    {"MODIFIES", 0, nullptr, false, ""},
    {"MODIFY", 0, nullptr, false, ""},
    {"MONTH", 0, nullptr, false, ""},
    {"MULTILINESTRING", 0, nullptr, false, ""},
    {"MULTIPOINT", 0, nullptr, false, ""},
    {"MULTIPOLYGON", 0, nullptr, false, ""},
    {"MUTEX", 0, nullptr, false, ""},
    {"NAME", 0, nullptr, false, ""},
    {"NAMES", 0, nullptr, false, ""},
    {"NATIONAL", 0, nullptr, false, ""},
    {"NATURAL", 0, nullptr, false, ""},
    {"NDB", 0, nullptr, false, ""},
    {"NDBCLUSTER", 0, nullptr, false, ""},
    {"NCHAR", 0, nullptr, false, ""},
    {"NEW", 0, nullptr, false, ""},
    {"NEXT", 0, nullptr, false, ""},
    {"NO", 0, nullptr, false, ""},
    {"NONE", 0, nullptr, false, ""},
    {"NOT", 0, nullptr, false, ""},
    {"NO_WRITE_TO_BINLOG", 0, nullptr, false, ""},
    {"NULL", 0, nullptr, false, ""},
    {"NUMERIC", 0, nullptr, false, ""},
    {"NVARCHAR", 0, nullptr, false, ""},
    {"OFFSET", 0, nullptr, false, ""},
    {"ON", 0, nullptr, false, ""},
    {"ONE", 0, nullptr, false, ""},
    {"ONE_SHOT", 0, nullptr, false, ""},
    {"OPEN", 0, nullptr, false, ""},
    {"OPTIMIZE", 0, nullptr, false, ""},
    {"OPTION", 0, nullptr, false, ""},
    {"OPTIONALLY", 0, nullptr, false, ""},
    {"OR", 0, nullptr, false, ""},
    {"ORDER", 0, nullptr, false, ""},
    {"OUT", 0, nullptr, false, ""},
    {"OUTER", 0, nullptr, false, ""},
    {"OUTFILE", 0, nullptr, false, ""},
    {"PACK_KEYS", 0, nullptr, false, ""},
    {"PARTIAL", 0, nullptr, false, ""},
    {"PASSWORD", 0, nullptr, false, ""},
    {"PHASE", 0, nullptr, false, ""},
    {"POINT", 0, nullptr, false, ""},
    {"POLYGON", 0, nullptr, false, ""},
    {"PRECISION", 0, nullptr, false, ""},
    {"PREPARE", 0, nullptr, false, ""},
    {"PREV", 0, nullptr, false, ""},
    {"PRIMARY", 0, nullptr, false, ""},
    {"PRIVILEGES", 0, nullptr, false, ""},
    {"PROCEDURE", 0, nullptr, false, ""},
    {"PROCESS", 0, nullptr, false, ""},
    {"PROCESSLIST", 0, nullptr, false, ""},
    {"PURGE", 0, nullptr, false, ""},
    {"QUARTER", 0, nullptr, false, ""},
    {"QUERY", 0, nullptr, false, ""},
    {"QUICK", 0, nullptr, false, ""},
    {"READ", 0, nullptr, false, ""},
    {"READS", 0, nullptr, false, ""},
    {"REAL", 0, nullptr, false, ""},
    {"RECOVER", 0, nullptr, false, ""},
    {"REDUNDANT", 0, nullptr, false, ""},
    {"REFERENCES", 0, nullptr, false, ""},
    {"REGEXP", 0, nullptr, false, ""},
    {"RELAY_LOG_FILE", 0, nullptr, false, ""},
    {"RELAY_LOG_POS", 0, nullptr, false, ""},
    {"RELAY_THREAD", 0, nullptr, false, ""},
    {"RELEASE", 0, nullptr, false, ""},
    {"RELOAD", 0, nullptr, false, ""},
    {"RENAME", 0, nullptr, false, ""},
    {"REPAIR", 0, nullptr, false, ""},
    {"REPEATABLE", 0, nullptr, false, ""},
    {"REPLACE", 0, nullptr, false, ""},
    {"REPLICATION", 0, nullptr, false, ""},
    {"REPEAT", 0, nullptr, false, ""},
    {"REQUIRE", 0, nullptr, false, ""},
    {"RESET", 0, nullptr, false, ""},
    {"RESTORE", 0, nullptr, false, ""},
    {"RESTRICT", 0, nullptr, false, ""},
    {"RESUME", 0, nullptr, false, ""},
    {"RETURN", 0, nullptr, false, ""},
    {"RETURNS", 0, nullptr, false, ""},
    {"REVOKE", 0, nullptr, false, ""},
    {"RIGHT", 0, nullptr, false, ""},
    {"RLIKE", 0, nullptr, false, ""},
    {"ROLLBACK", 0, nullptr, false, ""},
    {"ROLLUP", 0, nullptr, false, ""},
    {"ROUTINE", 0, nullptr, false, ""},
    {"ROW", 0, nullptr, false, ""},
    {"ROWS", 0, nullptr, false, ""},
    {"ROW_FORMAT", 0, nullptr, false, ""},
    {"RTREE", 0, nullptr, false, ""},
    {"SAVEPOINT", 0, nullptr, false, ""},
    {"SCHEMA", 0, nullptr, false, ""},
    {"SCHEMAS", 0, nullptr, false, ""},
    {"SECOND", 0, nullptr, false, ""},
    {"SECOND_MICROSECOND", 0, nullptr, false, ""},
    {"SECURITY", 0, nullptr, false, ""},
    {"SELECT", 0, nullptr, false, ""},
    {"SENSITIVE", 0, nullptr, false, ""},
    {"SEPARATOR", 0, nullptr, false, ""},
    {"SERIAL", 0, nullptr, false, ""},
    {"SERIALIZABLE", 0, nullptr, false, ""},
    {"SESSION", 0, nullptr, false, ""},
    {"SET", 0, nullptr, false, ""},
    {"SHARE", 0, nullptr, false, ""},
    {"SHOW", 0, nullptr, false, ""},
    {"SHUTDOWN", 0, nullptr, false, ""},
    {"SIGNED", 0, nullptr, false, ""},
    {"SIMPLE", 0, nullptr, false, ""},
    {"SLAVE", 0, nullptr, false, ""},
    {"SNAPSHOT", 0, nullptr, false, ""},
    {"SMALLINT", 0, nullptr, false, ""},
    {"SOME", 0, nullptr, false, ""},
    {"SONAME", 0, nullptr, false, ""},
    {"SOUNDS", 0, nullptr, false, ""},
    {"SPATIAL", 0, nullptr, false, ""},
    {"SPECIFIC", 0, nullptr, false, ""},
    {"SQL", 0, nullptr, false, ""},
    {"SQLEXCEPTION", 0, nullptr, false, ""},
    {"SQLSTATE", 0, nullptr, false, ""},
    {"SQLWARNING", 0, nullptr, false, ""},
    {"SQL_BIG_RESULT", 0, nullptr, false, ""},
    {"SQL_BUFFER_RESULT", 0, nullptr, false, ""},
    {"SQL_CALC_FOUND_ROWS", 0, nullptr, false, ""},
    {"SQL_NO_CACHE", 0, nullptr, false, ""},
    {"SQL_SMALL_RESULT", 0, nullptr, false, ""},
    {"SQL_THREAD", 0, nullptr, false, ""},
    {"SQL_TSI_SECOND", 0, nullptr, false, ""},
    {"SQL_TSI_MINUTE", 0, nullptr, false, ""},
    {"SQL_TSI_HOUR", 0, nullptr, false, ""},
    {"SQL_TSI_DAY", 0, nullptr, false, ""},
    {"SQL_TSI_WEEK", 0, nullptr, false, ""},
    {"SQL_TSI_MONTH", 0, nullptr, false, ""},
    {"SQL_TSI_QUARTER", 0, nullptr, false, ""},
    {"SQL_TSI_YEAR", 0, nullptr, false, ""},
    {"SSL", 0, nullptr, false, ""},
    {"START", 0, nullptr, false, ""},
    {"STARTING", 0, nullptr, false, ""},
    {"STATUS", 0, nullptr, false, ""},
    {"STOP", 0, nullptr, false, ""},
    {"STORAGE", 0, nullptr, false, ""},
    {"STRAIGHT_JOIN", 0, nullptr, false, ""},
    {"STRING", 0, nullptr, false, ""},
    {"STRIPED", 0, nullptr, false, ""},
    {"SUBJECT", 0, nullptr, false, ""},
    {"SUPER", 0, nullptr, false, ""},
    {"SUSPEND", 0, nullptr, false, ""},
    {"TABLE", 0, nullptr, false, ""},
    {"TABLES", 0, nullptr, false, ""},
    {"TABLESPACE", 0, nullptr, false, ""},
    {"TEMPORARY", 0, nullptr, false, ""},
    {"TEMPTABLE", 0, nullptr, false, ""},
    {"TERMINATED", 0, nullptr, false, ""},
    {"TEXT", 0, nullptr, false, ""},
    {"THEN", 0, nullptr, false, ""},
    {"TIME", 0, nullptr, false, ""},
    {"TIMESTAMP", 0, nullptr, false, ""},
    {"TIMESTAMPADD", 0, nullptr, false, ""},
    {"TIMESTAMPDIFF", 0, nullptr, false, ""},
    {"TINYBLOB", 0, nullptr, false, ""},
    {"TINYINT", 0, nullptr, false, ""},
    {"TINYTEXT", 0, nullptr, false, ""},
    {"TO", 0, nullptr, false, ""},
    {"TRAILING", 0, nullptr, false, ""},
    {"TRANSACTION", 0, nullptr, false, ""},
    {"TRIGGER", 0, nullptr, false, ""},
    {"TRIGGERS", 0, nullptr, false, ""},
    {"TRUE", 0, nullptr, false, ""},
    {"TRUNCATE", 0, nullptr, false, ""},
    {"TYPE", 0, nullptr, false, ""},
    {"TYPES", 0, nullptr, false, ""},
    {"UNCOMMITTED", 0, nullptr, false, ""},
    {"UNDEFINED", 0, nullptr, false, ""},
    {"UNDO", 0, nullptr, false, ""},
    {"UNICODE", 0, nullptr, false, ""},
    {"UNION", 0, nullptr, false, ""},
    {"UNIQUE", 0, nullptr, false, ""},
    {"UNKNOWN", 0, nullptr, false, ""},
    {"UNLOCK", 0, nullptr, false, ""},
    {"UNSIGNED", 0, nullptr, false, ""},
    {"UNTIL", 0, nullptr, false, ""},
    {"UPDATE", 0, nullptr, false, ""},
    {"UPGRADE", 0, nullptr, false, ""},
    {"USAGE", 0, nullptr, false, ""},
    {"USE", 0, nullptr, false, ""},
    {"USER", 0, nullptr, false, ""},
    {"USER_RESOURCES", 0, nullptr, false, ""},
    {"USE_FRM", 0, nullptr, false, ""},
    {"USING", 0, nullptr, false, ""},
    {"UTC_DATE", 0, nullptr, false, ""},
    {"UTC_TIME", 0, nullptr, false, ""},
    {"UTC_TIMESTAMP", 0, nullptr, false, ""},
    {"VALUE", 0, nullptr, false, ""},
    {"VALUES", 0, nullptr, false, ""},
    {"VARBINARY", 0, nullptr, false, ""},
    {"VARCHAR", 0, nullptr, false, ""},
    {"VARCHARACTER", 0, nullptr, false, ""},
    {"VARIABLES", 0, nullptr, false, ""},
    {"VARYING", 0, nullptr, false, ""},
    {"WARNINGS", 0, nullptr, false, ""},
    {"WEEK", 0, nullptr, false, ""},
    {"WHEN", 0, nullptr, false, ""},
    {"WHERE", 0, nullptr, false, ""},
    {"WHILE", 0, nullptr, false, ""},
    {"VIEW", 0, nullptr, false, ""},
    {"WITH", 0, nullptr, false, ""},
    {"WORK", 0, nullptr, false, ""},
    {"WRITE", 0, nullptr, false, ""},
    {"X509", 0, nullptr, false, ""},
    {"XOR", 0, nullptr, false, ""},
    {"XA", 0, nullptr, false, ""},
    {"YEAR", 0, nullptr, false, ""},
    {"YEAR_MONTH", 0, nullptr, false, ""},
    {"ZEROFILL", 0, nullptr, false, ""},
    {"ABS", 0, nullptr, false, ""},
    {"ACOS", 0, nullptr, false, ""},
    {"ADDDATE", 0, nullptr, false, ""},
    {"ADDTIME", 0, nullptr, false, ""},
    {"AES_ENCRYPT", 0, nullptr, false, ""},
    {"AES_DECRYPT", 0, nullptr, false, ""},
    {"AREA", 0, nullptr, false, ""},
    {"ASIN", 0, nullptr, false, ""},
    {"ASBINARY", 0, nullptr, false, ""},
    {"ASTEXT", 0, nullptr, false, ""},
    {"ASWKB", 0, nullptr, false, ""},
    {"ASWKT", 0, nullptr, false, ""},
    {"ATAN", 0, nullptr, false, ""},
    {"ATAN2", 0, nullptr, false, ""},
    {"BENCHMARK", 0, nullptr, false, ""},
    {"BIN", 0, nullptr, false, ""},
    {"BIT_COUNT", 0, nullptr, false, ""},
    {"BIT_OR", 0, nullptr, false, ""},
    {"BIT_AND", 0, nullptr, false, ""},
    {"BIT_XOR", 0, nullptr, false, ""},
    {"CAST", 0, nullptr, false, ""},
    {"CEIL", 0, nullptr, false, ""},
    {"CEILING", 0, nullptr, false, ""},
    {"BIT_LENGTH", 0, nullptr, false, ""},
    {"CENTROID", 0, nullptr, false, ""},
    {"CHAR_LENGTH", 0, nullptr, false, ""},
    {"CHARACTER_LENGTH", 0, nullptr, false, ""},
    {"COALESCE", 0, nullptr, false, ""},
    {"COERCIBILITY", 0, nullptr, false, ""},
    {"COMPRESS", 0, nullptr, false, ""},
    {"CONCAT", 0, nullptr, false, ""},
    {"CONCAT_WS", 0, nullptr, false, ""},
    {"CONNECTION_ID", 0, nullptr, false, ""},
    {"CONV", 0, nullptr, false, ""},
    {"CONVERT_TZ", 0, nullptr, false, ""},
    {"COUNT", 0, nullptr, false, ""},
    {"COS", 0, nullptr, false, ""},
    {"COT", 0, nullptr, false, ""},
    {"CRC32", 0, nullptr, false, ""},
    {"CROSSES", 0, nullptr, false, ""},
    {"CURDATE", 0, nullptr, false, ""},
    {"CURTIME", 0, nullptr, false, ""},
    {"DATE_ADD", 0, nullptr, false, ""},
    {"DATEDIFF", 0, nullptr, false, ""},
    {"DATE_FORMAT", 0, nullptr, false, ""},
    {"DATE_SUB", 0, nullptr, false, ""},
    {"DAYNAME", 0, nullptr, false, ""},
    {"DAYOFMONTH", 0, nullptr, false, ""},
    {"DAYOFWEEK", 0, nullptr, false, ""},
    {"DAYOFYEAR", 0, nullptr, false, ""},
    {"DEGREES", 0, nullptr, false, ""},
    {"DIMENSION", 0, nullptr, false, ""},
    {"DISJOINT", 0, nullptr, false, ""},
    {"ELT", 0, nullptr, false, ""},
    {"ENDPOINT", 0, nullptr, false, ""},
    {"ENVELOPE", 0, nullptr, false, ""},
    {"EQUALS", 0, nullptr, false, ""},
    {"EXTERIORRING", 0, nullptr, false, ""},
    {"EXTRACT", 0, nullptr, false, ""},
    {"EXP", 0, nullptr, false, ""},
    {"EXPORT_SET", 0, nullptr, false, ""},
    {"FIELD", 0, nullptr, false, ""},
    {"FIND_IN_SET", 0, nullptr, false, ""},
    {"FLOOR", 0, nullptr, false, ""},
    {"FORMAT", 0, nullptr, false, ""},
    {"FOUND_ROWS", 0, nullptr, false, ""},
    {"FROM_DAYS", 0, nullptr, false, ""},
    {"FROM_UNIXTIME", 0, nullptr, false, ""},
    {"GET_LOCK", 0, nullptr, false, ""},
    {"GEOMETRYN", 0, nullptr, false, ""},
    {"GEOMETRYTYPE", 0, nullptr, false, ""},
    {"GEOMCOLLFROMTEXT", 0, nullptr, false, ""},
    {"GEOMCOLLFROMWKB", 0, nullptr, false, ""},
    {"GEOMETRYCOLLECTIONFROMTEXT", 0, nullptr, false, ""},
    {"GEOMETRYCOLLECTIONFROMWKB", 0, nullptr, false, ""},
    {"GEOMETRYFROMTEXT", 0, nullptr, false, ""},
    {"GEOMETRYFROMWKB", 0, nullptr, false, ""},
    {"GEOMFROMTEXT", 0, nullptr, false, ""},
    {"GEOMFROMWKB", 0, nullptr, false, ""},
    {"GLENGTH", 0, nullptr, false, ""},
    {"GREATEST", 0, nullptr, false, ""},
    {"GROUP_CONCAT", 0, nullptr, false, ""},
    {"GROUP_UNIQUE_USERS", 0, nullptr, false, ""},
    {"HEX", 0, nullptr, false, ""},
    {"IFNULL", 0, nullptr, false, ""},
    {"INET_ATON", 0, nullptr, false, ""},
    {"INET_NTOA", 0, nullptr, false, ""},
    {"INSTR", 0, nullptr, false, ""},
    {"INTERIORRINGN", 0, nullptr, false, ""},
    {"INTERSECTS", 0, nullptr, false, ""},
    {"ISCLOSED", 0, nullptr, false, ""},
    {"ISEMPTY", 0, nullptr, false, ""},
    {"ISNULL", 0, nullptr, false, ""},
    {"IS_FREE_LOCK", 0, nullptr, false, ""},
    {"IS_USED_LOCK", 0, nullptr, false, ""},
    {"JSON_ARRAY_APPEND", 0, nullptr, false, ""},
    {"JSON_ARRAY", 0, nullptr, false, ""},
    {"JSON_CONTAINS", 0, nullptr, false, ""},
    {"JSON_DEPTH", 0, nullptr, false, ""},
    {"JSON_EXTRACT", 0, nullptr, false, ""},
    {"JSON_INSERT", 0, nullptr, false, ""},
    {"JSON_KEYS", 0, nullptr, false, ""},
    {"JSON_LENGTH", 0, nullptr, false, ""},
    {"JSON_MERGE", 0, nullptr, false, ""},
    {"JSON_QUOTE", 0, nullptr, false, ""},
    {"JSON_REPLACE", 0, nullptr, false, ""},
    {"JSON_ROWOBJECT", 0, nullptr, false, ""},
    {"JSON_SEARCH", 0, nullptr, false, ""},
    {"JSON_SET", 0, nullptr, false, ""},
    {"JSON_TYPE", 0, nullptr, false, ""},
    {"JSON_UNQUOTE", 0, nullptr, false, ""},
    {"JSON_VALID", 0, nullptr, false, ""},
    {"JSON_CONTAINS_PATH", 0, nullptr, false, ""},
    {"LAST_INSERT_ID", 0, nullptr, false, ""},
    {"ISSIMPLE", 0, nullptr, false, ""},
    {"LAST_DAY", 0, nullptr, false, ""},
    {"LCASE", 0, nullptr, false, ""},
    {"LEAST", 0, nullptr, false, ""},
    {"LENGTH", 0, nullptr, false, ""},
    {"LN", 0, nullptr, false, ""},
    {"LINEFROMTEXT", 0, nullptr, false, ""},
    {"LINEFROMWKB", 0, nullptr, false, ""},
    {"LINESTRINGFROMTEXT", 0, nullptr, false, ""},
    {"LINESTRINGFROMWKB", 0, nullptr, false, ""},
    {"LOAD_FILE", 0, nullptr, false, ""},
    {"LOCATE", 0, nullptr, false, ""},
    {"LOG", 0, nullptr, false, ""},
    {"LOG2", 0, nullptr, false, ""},
    {"LOG10", 0, nullptr, false, ""},
    {"LOWER", 0, nullptr, false, ""},
    {"LPAD", 0, nullptr, false, ""},
    {"LTRIM", 0, nullptr, false, ""},
    {"MAKE_SET", 0, nullptr, false, ""},
    {"MAKEDATE", 0, nullptr, false, ""},
    {"MAKETIME", 0, nullptr, false, ""},
    {"MASTER_POS_WAIT", 0, nullptr, false, ""},
    {"MAX", 0, nullptr, false, ""},
    {"MBRCONTAINS", 0, nullptr, false, ""},
    {"MBRDISJOINT", 0, nullptr, false, ""},
    {"MBREQUAL", 0, nullptr, false, ""},
    {"MBRINTERSECTS", 0, nullptr, false, ""},
    {"MBROVERLAPS", 0, nullptr, false, ""},
    {"MBRTOUCHES", 0, nullptr, false, ""},
    {"MBRWITHIN", 0, nullptr, false, ""},
    {"MD5", 0, nullptr, false, ""},
    {"MID", 0, nullptr, false, ""},
    {"MIN", 0, nullptr, false, ""},
    {"MLINEFROMTEXT", 0, nullptr, false, ""},
    {"MLINEFROMWKB", 0, nullptr, false, ""},
    {"MPOINTFROMTEXT", 0, nullptr, false, ""},
    {"MPOINTFROMWKB", 0, nullptr, false, ""},
    {"MPOLYFROMTEXT", 0, nullptr, false, ""},
    {"MPOLYFROMWKB", 0, nullptr, false, ""},
    {"MONTHNAME", 0, nullptr, false, ""},
    {"MULTILINESTRINGFROMTEXT", 0, nullptr, false, ""},
    {"MULTILINESTRINGFROMWKB", 0, nullptr, false, ""},
    {"MULTIPOINTFROMTEXT", 0, nullptr, false, ""},
    {"MULTIPOINTFROMWKB", 0, nullptr, false, ""},
    {"MULTIPOLYGONFROMTEXT", 0, nullptr, false, ""},
    {"MULTIPOLYGONFROMWKB", 0, nullptr, false, ""},
    {"NAME_CONST", 0, nullptr, false, ""},
    {"NOW", 0, nullptr, false, ""},
    {"NULLIF", 0, nullptr, false, ""},
    {"NUMGEOMETRIES", 0, nullptr, false, ""},
    {"NUMINTERIORRINGS", 0, nullptr, false, ""},
    {"NUMPOINTS", 0, nullptr, false, ""},
    {"OCTET_LENGTH", 0, nullptr, false, ""},
    {"OCT", 0, nullptr, false, ""},
    {"ORD", 0, nullptr, false, ""},
    {"OVERLAPS", 0, nullptr, false, ""},
    {"PERIOD_ADD", 0, nullptr, false, ""},
    {"PERIOD_DIFF", 0, nullptr, false, ""},
    {"PI", 0, nullptr, false, ""},
    {"POINTFROMTEXT", 0, nullptr, false, ""},
    {"POINTFROMWKB", 0, nullptr, false, ""},
    {"POINTN", 0, nullptr, false, ""},
    {"POLYFROMTEXT", 0, nullptr, false, ""},
    {"POLYFROMWKB", 0, nullptr, false, ""},
    {"POLYGONFROMTEXT", 0, nullptr, false, ""},
    {"POLYGONFROMWKB", 0, nullptr, false, ""},
    {"POSITION", 0, nullptr, false, ""},
    {"POW", 0, nullptr, false, ""},
    {"POWER", 0, nullptr, false, ""},
    {"QUOTE", 0, nullptr, false, ""},
    {"RADIANS", 0, nullptr, false, ""},
    {"RAND", 0, nullptr, false, ""},
    {"RELEASE_LOCK", 0, nullptr, false, ""},
    {"REVERSE", 0, nullptr, false, ""},
    {"ROUND", 0, nullptr, false, ""},
    {"ROW_COUNT", 0, nullptr, false, ""},
    {"RPAD", 0, nullptr, false, ""},
    {"RTRIM", 0, nullptr, false, ""},
    {"SEC_TO_TIME", 0, nullptr, false, ""},
    {"SESSION_USER", 0, nullptr, false, ""},
    {"SUBDATE", 0, nullptr, false, ""},
    {"SIGN", 0, nullptr, false, ""},
    {"SIN", 0, nullptr, false, ""},
    {"SHA", 0, nullptr, false, ""},
    {"SHA1", 0, nullptr, false, ""},
    {"SLEEP", 0, nullptr, false, ""},
    {"SOUNDEX", 0, nullptr, false, ""},
    {"SPACE", 0, nullptr, false, ""},
    {"SQRT", 0, nullptr, false, ""},
    {"SRID", 0, nullptr, false, ""},
    {"STARTPOINT", 0, nullptr, false, ""},
    {"STD", 0, nullptr, false, ""},
    {"STDDEV", 0, nullptr, false, ""},
    {"STDDEV_POP", 0, nullptr, false, ""},
    {"STDDEV_SAMP", 0, nullptr, false, ""},
    {"STR_TO_DATE", 0, nullptr, false, ""},
    {"STRCMP", 0, nullptr, false, ""},
    {"SUBSTR", 0, nullptr, false, ""},
    {"SUBSTRING", 0, nullptr, false, ""},
    {"SUBSTRING_INDEX", 0, nullptr, false, ""},
    {"SUBTIME", 0, nullptr, false, ""},
    {"SUM", 0, nullptr, false, ""},
    {"SYSDATE", 0, nullptr, false, ""},
    {"SYSTEM_USER", 0, nullptr, false, ""},
    {"TAN", 0, nullptr, false, ""},
    {"TIME_FORMAT", 0, nullptr, false, ""},
    {"TIME_TO_SEC", 0, nullptr, false, ""},
    {"TIMEDIFF", 0, nullptr, false, ""},
    {"TO_DAYS", 0, nullptr, false, ""},
    {"TOUCHES", 0, nullptr, false, ""},
    {"TRIM", 0, nullptr, false, ""},
    {"UCASE", 0, nullptr, false, ""},
    {"UNCOMPRESS", 0, nullptr, false, ""},
    {"UNCOMPRESSED_LENGTH", 0, nullptr, false, ""},
    {"UNHEX", 0, nullptr, false, ""},
    {"UNIQUE_USERS", 0, nullptr, false, ""},
    {"UNIX_TIMESTAMP", 0, nullptr, false, ""},
    {"UPPER", 0, nullptr, false, ""},
    {"UUID", 0, nullptr, false, ""},
    {"VARIANCE", 0, nullptr, false, ""},
    {"VAR_POP", 0, nullptr, false, ""},
    {"VAR_SAMP", 0, nullptr, false, ""},
    {"VERSION", 0, nullptr, false, ""},
    {"WEEKDAY", 0, nullptr, false, ""},
    {"WEEKOFYEAR", 0, nullptr, false, ""},
    {"WITHIN", 0, nullptr, false, ""},
    {"X", 0, nullptr, false, ""},
    {"Y", 0, nullptr, false, ""},
    {"YEARWEEK", 0, nullptr, false, ""},
    /* end sentinel */
    {(char *)nullptr, 0, nullptr, false, ""}};

static const char *load_default_groups[] = {"mysql", "client", nullptr};

#ifdef HAVE_READLINE
/*
 HIST_ENTRY is defined for libedit, but not for the real readline
 Need to redefine it for real readline to find it
*/
#if !defined(HAVE_HIST_ENTRY)
typedef struct _hist_entry {
  const char *line;
  const char *data;
} HIST_ENTRY;
#endif

extern "C" int add_history(const char *command); /* From readline directory */
extern "C" int read_history(const char *command);
extern "C" int write_history(const char *command);
extern "C" HIST_ENTRY *history_get(int num);
extern "C" int history_length;
static int not_in_history(const char *line);
static void initialize_readline(char *name);
#endif /* HAVE_READLINE */

static COMMANDS *find_command(char *name);
static COMMANDS *find_command(char cmd_name);
static bool add_line(String &buffer, char *line, size_t line_length,
                     char *in_string, bool *ml_comment, bool truncated);
static void remove_cntrl(String *buffer);
static void print_table_data(MYSQL_RES *result);
static void print_table_data_html(MYSQL_RES *result);
static void print_table_data_xml(MYSQL_RES *result);
static void print_tab_data(MYSQL_RES *result);
static void print_table_data_vertically(MYSQL_RES *result);
static void print_warnings(void);
static ulong start_timer(void);
static void end_timer(ulong start_time, char *buff);
static void mysql_end_timer(ulong start_time, char *buff);
static void nice_time(double sec, char *buff, bool part_second);
static void kill_query(const char *reason);
extern "C" void mysql_end(int sig);
extern "C" void handle_ctrlc_signal(int);
extern "C" void handle_quit_signal(int sig);
#if defined(HAVE_TERMIOS_H) && defined(GWINSZ_IN_SYS_IOCTL)
static void window_resize(int);
#endif

const char DELIMITER_NAME[] = "delimiter";
const uint DELIMITER_NAME_LEN = sizeof(DELIMITER_NAME) - 1;
inline bool is_delimiter_command(char *name, ulong len) {
  /*
    Delimiter command has a parameter, so the length of the whole command
    is larger than DELIMITER_NAME_LEN.  We don't care the parameter, so
    only name(first DELIMITER_NAME_LEN bytes) is checked.
  */
  return (len >= DELIMITER_NAME_LEN &&
          !my_strnncoll(
              charset_info, pointer_cast<uchar *>(name), DELIMITER_NAME_LEN,
              pointer_cast<const uchar *>(DELIMITER_NAME), DELIMITER_NAME_LEN));
}

/**
   Get the index of a command in the commands array.

   @param cmd_char    Short form command.

   @return int
     The index of the command is returned if it is found, else -1 is returned.
*/
inline int get_command_index(char cmd_char) {
  /*
    All client-specific commands are in the first part of commands array
    and have a function to implement it.
  */
  for (uint i = 0; *commands[i].func != nullptr; i++)
    if (commands[i].cmd_char == cmd_char) return i;
  return -1;
}

static int delimiter_index = -1;
static int charset_index = -1;
static bool real_binary_mode = false;

#ifdef _WIN32
BOOL windows_ctrl_handler(DWORD fdwCtrlType) {
  switch (fdwCtrlType) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
      handle_ctrlc_signal(SIGINT);
      /* Indicate that signal has beed handled. */
      return true;
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
      handle_quit_signal(SIGINT + 1);
  }
  /* Pass signal to the next control handler function. */
  return false;
}
#endif

int main(int argc, char *argv[]) {

  /*DPDK eal init
    DPDK parameters come after the '---'
  */

  char* eal_argv[20];
  int eal_argc = 0;

  for(int i=0; i<argc; i++){
    if(strcmp(argv[i], "---") == 0){
      int k=0;
      for(int j=i; j<argc; j++){
        eal_argv[k] = argv[j];
        k++;
      }
      eal_argc = k;
      argc = argc - k - 1;
      break;
    }
  }

  int res = rte_eal_init(eal_argc, eal_argv);

  if (res < 0)
  {
      PRINT_DPDK_ERROR("Unable to init RTE: %s.\n", rte_strerror(rte_errno));
      return -1;
  }

  char buff[80];

  MY_INIT(argv[0]);
  DBUG_TRACE;
  DBUG_PROCESS(argv[0]);

  charset_index = get_command_index('C');
  delimiter_index = get_command_index('d');
  delimiter_str = delimiter;
  default_prompt = my_strdup(
      PSI_NOT_INSTRUMENTED,
      getenv("MYSQL_PS1") ? getenv("MYSQL_PS1") : "mysql> ", MYF(MY_WME));
  current_prompt = my_strdup(PSI_NOT_INSTRUMENTED, default_prompt, MYF(MY_WME));
  prompt_counter = 0;

  outfile[0] = 0;              // no (default) outfile
  my_stpcpy(pager, "stdout");  // the default, if --pager wasn't given
  {
    char *tmp = getenv("PAGER");
    if (tmp && strlen(tmp)) {
      default_pager_set = true;
      my_stpcpy(default_pager, tmp);
    }
  }
  if (!isatty(0) || !isatty(1)) {
    status.batch = true;
    opt_silent = 1;
    ignore_errors = false;
  } else
    status.add_to_history = true;
  status.exit_status = 1;

  {
    /*
     The file descriptor-layer may be out-of-sync with the file-number layer,
     so we make sure that "stdout" is really open.  If its file is closed then
     explicitly close the FD layer.
    */
    int stdout_fileno_copy;
    stdout_fileno_copy = dup(fileno(stdout)); /* Okay if fileno fails. */
    if (stdout_fileno_copy == -1) {
      fclose(stdout);
#ifdef LINUX_ALPINE
      // On Alpine linux we need to open a dummy file, so that the first
      // call to socket() does not get file number 1
      // If socket gets file number 1, then everything printed to stdout
      // will be sent back to the server over the socket connection.
      fopen("/dev/null", "r");
#endif
    } else
      close(stdout_fileno_copy); /* Clean up dup(). */
  }

#ifdef _WIN32
  /* Convert command line parameters from UTF16LE to UTF8MB4. */
  my_win_translate_command_line_args(&my_charset_utf8mb4_bin, &argc, &argv);
#endif

  my_getopt_use_args_separator = true;
  if (load_defaults("my", load_default_groups, &argc, &argv, &argv_alloc)) {
    my_end(0);
    return EXIT_FAILURE;
  }
  my_getopt_use_args_separator = false;

  get_current_os_user();
  get_current_os_sudouser();
  if (get_options(argc, (char **)argv)) {
    my_end(0);
    return EXIT_FAILURE;
  }
  if (status.batch && !status.line_buff &&
      !(status.line_buff = batch_readline_init(MAX_BATCH_BUFFER_SIZE, stdin))) {
    put_info(
        "Can't initialize batch_readline - may be the input source is "
        "a directory or a block device.",
        INFO_ERROR, 0);
    my_end(0);
    return EXIT_FAILURE;
  }
  if (!opt_binary_as_hex_set_explicitly && isatty(0) && isatty(1))
    opt_binhex = true;
  if (mysql_server_init(0, nullptr, nullptr)) {
    put_error(nullptr);
    my_end(0);
    return EXIT_FAILURE;
  }
  glob_buffer.mem_realloc((status.batch) ? batch_io_size : 512);
  completion_hash_init(&ht, 128);
  init_alloc_root(PSI_NOT_INSTRUMENTED, &hash_mem_root, 16384, 0);
  memset(&mysql, 0, sizeof(mysql));
  if (sql_connect(current_host, current_db, current_user, opt_password,
                  opt_silent)) {
    quick = true;  // Avoid history
    status.exit_status = 1;
    mysql_end(-1);
  }
  if (!status.batch) ignore_errors = true;  // Don't abort monitor

#ifndef _WIN32
  signal(SIGINT, handle_ctrlc_signal);  // Catch SIGINT to clean up
  signal(SIGQUIT, mysql_end);           // Catch SIGQUIT to clean up
  signal(SIGHUP, handle_quit_signal);   // Catch SIGHUP to clean up
#else
  SetConsoleCtrlHandler((PHANDLER_ROUTINE)windows_ctrl_handler, true);
#endif

#if defined(HAVE_TERMIOS_H) && defined(GWINSZ_IN_SYS_IOCTL)
  /* Readline will call this if it installs a handler */
  signal(SIGWINCH, window_resize);
  /* call the SIGWINCH handler to get the default term width */
  window_resize(0);
#endif

  put_info("Welcome to the MySQL monitor.  Commands end with ; or \\g.",
           INFO_INFO);
  snprintf(glob_buffer.ptr(), glob_buffer.alloced_length(),
           "Your MySQL connection id is %lu\nServer version: %s\n",
           mysql_thread_id(&mysql), server_version_string(&mysql));
  put_info(glob_buffer.ptr(), INFO_INFO);

  put_info(ORACLE_WELCOME_COPYRIGHT_NOTICE("2000"), INFO_INFO);

  if (!status.batch) {
    // history ignore patterns are initialized to default values
    ignore_matcher.add_patterns(HI_DEFAULTS);

    /*
      Additional patterns may be supplied using either --histignore option or
      MYSQL_HISTIGNORE environment variable. If supplied, they'll get appended
      to the default patterns. In case both are specified, pattern(s) supplied
      using --histignore option will be used.
    */
    if (opt_histignore)
      ignore_matcher.add_patterns(opt_histignore);
    else if (getenv("MYSQL_HISTIGNORE"))
      ignore_matcher.add_patterns(getenv("MYSQL_HISTIGNORE"));

#ifdef HAVE_READLINE
    if (!quick) {
      initialize_readline(const_cast<char *>(my_progname));

      /* read-history from file, default ~/.mysql_history*/
      if (getenv("MYSQL_HISTFILE"))
        histfile = my_strdup(PSI_NOT_INSTRUMENTED, getenv("MYSQL_HISTFILE"),
                             MYF(MY_WME));
      else if (getenv("HOME")) {
        histfile = (char *)my_malloc(
            PSI_NOT_INSTRUMENTED,
            (uint)strlen(getenv("HOME")) + (uint)strlen("/.mysql_history") + 2,
            MYF(MY_WME));
        if (histfile) sprintf(histfile, "%s/.mysql_history", getenv("HOME"));
        char link_name[FN_REFLEN];
        if (my_readlink(link_name, histfile, 0) == 0 &&
            strncmp(link_name, "/dev/null", 10) == 0) {
          /* The .mysql_history file is a symlink to /dev/null, don't use it */
          my_free(histfile);
          histfile = nullptr;
        }
      }

      /* We used to suggest setting MYSQL_HISTFILE=/dev/null. */
      if (histfile && strncmp(histfile, "/dev/null", 10) == 0)
        histfile = nullptr;

      if (histfile && histfile[0]) {
        if (verbose) tee_fprintf(stdout, "Reading history-file %s\n", histfile);
        read_history(histfile);
        if (!(histfile_tmp =
                  (char *)my_malloc(PSI_NOT_INSTRUMENTED,
                                    (uint)strlen(histfile) + 5, MYF(MY_WME)))) {
          fprintf(stderr, "Couldn't allocate memory for temp histfile!\n");
          return EXIT_FAILURE;
        }
        sprintf(histfile_tmp, "%s.TMP", histfile);
      }
    }
#endif
  }

  sprintf(
      buff, "%s",
      "Type 'help;' or '\\h' for help. Type '\\c' to clear the current input "
      "statement.\n");
  put_info(buff, INFO_INFO);

  uint protocol = MYSQL_PROTOCOL_DEFAULT;
  uint ssl_mode = 0;
  if (!mysql_get_option(&mysql, MYSQL_OPT_PROTOCOL, &protocol) &&
      !mysql_get_option(&mysql, MYSQL_OPT_SSL_MODE, &ssl_mode)) {
    if (protocol == MYSQL_PROTOCOL_SOCKET && ssl_mode >= SSL_MODE_REQUIRED)
      put_info(
          "You are enforcing ssl connection via unix socket. Please consider\n"
          "switching ssl off as it does not make connection via unix socket\n"
          "any more secure.",
          INFO_INFO);
  }
  status.exit_status = read_and_execute(!status.batch);
  if (opt_outfile) end_tee();
  mysql_end(0);
  return 0;  // Keep compiler happy
}

void mysql_end(int sig) {
#ifndef _WIN32
  /*
    Ingnoring SIGQUIT, SIGINT and SIGHUP signals when cleanup process starts.
    This will help in resolving the double free issues, which occures in case
    the signal handler function is started in between the clean up function.
  */
  signal(SIGQUIT, SIG_IGN);
  signal(SIGINT, SIG_IGN);
  signal(SIGHUP, SIG_IGN);
#endif

  mysql_close(&mysql);
#ifdef HAVE_READLINE
  if (!status.batch && !quick && histfile && histfile[0]) {
    /* write-history */
    if (verbose) tee_fprintf(stdout, "Writing history-file %s\n", histfile);
    if (!write_history(histfile_tmp))
      my_rename(histfile_tmp, histfile, MYF(MY_WME));
  }
  batch_readline_end(status.line_buff);
  completion_hash_free(&ht);
  free_root(&hash_mem_root, MYF(0));

  my_free(histfile);
  my_free(histfile_tmp);
#endif
  my_free(opt_histignore);

  my_free(current_os_user);
  my_free(current_os_sudouser);

  if (opt_syslog) my_closelog();

  if (sig >= 0) put_info(sig ? "Aborted" : "Bye", INFO_RESULT);
  glob_buffer.mem_free();
  old_buffer.mem_free();
  processed_prompt.mem_free();
  my_free(server_version);
  my_free(opt_password);
  my_free(opt_mysql_unix_port);
  my_free(current_db);
  my_free(current_host);
  my_free(current_user);
  my_free(full_username);
  my_free(part_username);
  my_free(default_prompt);
#if defined(_WIN32)
  my_free(shared_memory_base_name);
#endif
  my_free(current_prompt);
  mysql_server_end();
  my_end(my_end_arg);
  exit(status.exit_status);
}

/**
  SIGINT signal handler.

    This function handles SIGINT (Ctrl - C). It sends a 'KILL [QUERY]' command
    to the server if a query is currently executing. On Windows, 'Ctrl - Break'
    is treated alike.

  FIXME: POSIX allows only a very limited set of interactions from signal
  handlers, as the main thread could have nearly any state at the time of the
  signal and is suspended until the signal handler returns. In particular,
  only variables of type sig_atomic_t can be set and tested, and most C library
  functions (including malloc()) are banned. Thus, calling kill_query() here
  is forbidden and should not be done.
*/

void handle_ctrlc_signal(int) {
  sigint_received = true;

  /* Skip rest if --sigint-ignore is used. */
  if (opt_sigint_ignore) return;

  if (executing_query) kill_query("^C");
  /* else, do nothing, just terminate the current line (like /c command). */
  return;
}

/**
   Handler to perform a cleanup and quit the program.

     This function would send a 'KILL [QUERY]' command to the server if a
     query is currently executing and then it invokes mysql_thread_end()/
     mysql_end() in order to terminate the mysql client process.

  @param sig              Signal number
*/

void handle_quit_signal(int sig) {
  const char *reason = "Terminal close";

  if (!executing_query) {
    tee_fprintf(stdout, "%s -- exit!\n", reason);
    goto err;
  }

  kill_query(reason);

err:
#ifdef _WIN32
  /*
   When a signal is raised on Windows, the OS creates a new thread to
   handle the interrupt. Once that thread completes, the main thread
   continues running only to find that it's resources have already been
   free'd when the signal handler called mysql_end().
  */
  mysql_thread_end();
  return;
#else
  mysql_end(sig);
#endif
}

/* Send 'KILL QUERY' command to the server. */
static void kill_query(const char *reason) {
  char kill_buffer[40];
  MYSQL *kill_mysql = nullptr;

  kill_mysql = mysql_init(kill_mysql);
  init_connection_options(kill_mysql);

#ifdef HAVE_SETNS
  if (opt_network_namespace && set_network_namespace(opt_network_namespace)) {
    goto err;
  }
#endif

  if (!mysql_real_connect(kill_mysql, current_host, current_user, opt_password,
                          "", opt_mysql_port, opt_mysql_unix_port, 0)) {
#ifdef HAVE_SETNS
    if (opt_network_namespace) (void)restore_original_network_namespace();
#endif
    tee_fprintf(stdout,
                "%s -- Sorry, cannot connect to the server to kill "
                "query, giving up ...\n",
                reason);
    goto err;
  }

#ifdef HAVE_SETNS
  if (opt_network_namespace && restore_original_network_namespace()) goto err;
#endif

  interrupted_query = true;

  /* mysqld < 5 does not understand KILL QUERY, skip to KILL CONNECTION */
  sprintf(kill_buffer, "KILL %s%lu",
          (mysql_get_server_version(&mysql) < 50000) ? "" : "QUERY ",
          mysql_thread_id(&mysql));

  if (verbose)
    tee_fprintf(stdout, "%s -- sending \"%s\" to server ...\n", reason,
                kill_buffer);
  mysql_real_query(kill_mysql, kill_buffer,
                   static_cast<ulong>(strlen(kill_buffer)));
  tee_fprintf(stdout, "%s -- query aborted\n", reason);

err:
#ifdef HAVE_SETNS
  if (opt_network_namespace) (void)release_network_namespace_resources();
#endif
  mysql_close(kill_mysql);

  return;
}

#if defined(HAVE_TERMIOS_H) && defined(GWINSZ_IN_SYS_IOCTL)
void window_resize(int) {
  struct winsize window_size;

  if (ioctl(fileno(stdin), TIOCGWINSZ, &window_size) == 0)
    terminal_width = window_size.ws_col;
}
#endif

static struct my_option my_long_options[] = {
    {"help", '?', "Display this help and exit.", nullptr, nullptr, nullptr,
     GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"help", 'I', "Synonym for -?", nullptr, nullptr, nullptr, GET_NO_ARG,
     NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"auto-rehash", OPT_AUTO_REHASH,
     "Enable automatic rehashing. One doesn't need to use 'rehash' to get "
     "table "
     "and field completion, but startup and reconnecting may take a longer "
     "time. "
     "Disable with --disable-auto-rehash.",
     &opt_rehash, &opt_rehash, nullptr, GET_BOOL, NO_ARG, 1, 0, 0, nullptr, 0,
     nullptr},
    {"no-auto-rehash", 'A',
     "No automatic rehashing. One has to use 'rehash' to get table and field "
     "completion. This gives a quicker start of mysql and disables rehashing "
     "on reconnect.",
     nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"auto-vertical-output", OPT_AUTO_VERTICAL_OUTPUT,
     "Automatically switch to vertical output mode if the result is wider "
     "than the terminal width.",
     &auto_vertical_output, &auto_vertical_output, nullptr, GET_BOOL, NO_ARG, 0,
     0, 0, nullptr, 0, nullptr},
    {"batch", 'B',
     "Don't use history file. Disable interactive behavior. (Enables "
     "--silent.)",
     nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"bind-address", 0, "IP address to bind to.", (uchar **)&opt_bind_addr,
     (uchar **)&opt_bind_addr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr,
     0, nullptr},
    {"binary-as-hex", OPT_MYSQL_BINARY_AS_HEX,
     "Print binary data as hex. Enabled by default for interactive terminals.",
     &opt_binhex, &opt_binhex, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"character-sets-dir", OPT_CHARSETS_DIR,
     "Directory for character set files.", &charsets_dir, &charsets_dir,
     nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"column-type-info", OPT_COLUMN_TYPES, "Display column type information.",
     &column_types_flag, &column_types_flag, nullptr, GET_BOOL, NO_ARG, 0, 0, 0,
     nullptr, 0, nullptr},
    {"comments", 'c',
     "Preserve comments. Send comments to the server."
     " The default is --skip-comments (discard comments), enable with "
     "--comments.",
     &preserve_comments, &preserve_comments, nullptr, GET_BOOL, NO_ARG, 0, 0, 0,
     nullptr, 0, nullptr},
    {"compress", 'C', "Use compression in server/client protocol.",
     &opt_compress, &opt_compress, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr,
     0, nullptr},
#ifdef DBUG_OFF
    {"debug", '#', "This is a non-debug version. Catch this and exit.", 0, 0, 0,
     GET_DISABLED, OPT_ARG, 0, 0, 0, 0, 0, 0},
    {"debug-check", OPT_DEBUG_CHECK,
     "This is a non-debug version. Catch this and exit.", 0, 0, 0, GET_DISABLED,
     NO_ARG, 0, 0, 0, 0, 0, 0},
    {"debug-info", 'T', "This is a non-debug version. Catch this and exit.", 0,
     0, 0, GET_DISABLED, NO_ARG, 0, 0, 0, 0, 0, 0},
#else
    {"debug", '#', "Output debug log.", &default_dbug_option,
     &default_dbug_option, nullptr, GET_STR, OPT_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"debug-check", OPT_DEBUG_CHECK,
     "Check memory and open file usage at exit.", &debug_check_flag,
     &debug_check_flag, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"debug-info", 'T', "Print some debug info at exit.", &debug_info_flag,
     &debug_info_flag, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
#endif
    {"database", 'D', "Database to use.", &current_db, &current_db, nullptr,
     GET_STR_ALLOC, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"default-character-set", OPT_DEFAULT_CHARSET,
     "Set the default character set.", &default_charset, &default_charset,
     nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"delimiter", OPT_DELIMITER, "Delimiter to be used.", &delimiter_str,
     &delimiter_str, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"enable_cleartext_plugin", OPT_ENABLE_CLEARTEXT_PLUGIN,
     "Enable/disable the clear text authentication plugin.",
     &opt_enable_cleartext_plugin, &opt_enable_cleartext_plugin, nullptr,
     GET_BOOL, OPT_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"execute", 'e',
     "Execute command and quit. (Disables --force and history file.)", nullptr,
     nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"vertical", 'E', "Print the output of a query (rows) vertically.",
     &vertical, &vertical, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"force", 'f', "Continue even if we get an SQL error.", &ignore_errors,
     &ignore_errors, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"histignore", OPT_HISTIGNORE,
     "A colon-separated list of patterns to "
     "keep statements from getting logged into syslog and mysql history.",
     &opt_histignore, &opt_histignore, nullptr, GET_STR_ALLOC, REQUIRED_ARG, 0,
     0, 0, nullptr, 0, nullptr},
    {"named-commands", 'G',
     "Enable named commands. Named commands mean this program's internal "
     "commands; see mysql> help . When enabled, the named commands can be "
     "used from any line of the query, otherwise only from the first line, "
     "before an enter. Disable with --disable-named-commands. This option "
     "is disabled by default.",
     &named_cmds, &named_cmds, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"ignore-spaces", 'i', "Ignore space after function names.", &ignore_spaces,
     &ignore_spaces, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"init-command", OPT_INIT_COMMAND,
     "SQL Command to execute when connecting to MySQL server. Will "
     "automatically be re-executed when reconnecting.",
     &opt_init_command, &opt_init_command, nullptr, GET_STR, REQUIRED_ARG, 0, 0,
     0, nullptr, 0, nullptr},
    {"local-infile", OPT_LOCAL_INFILE, "Enable/disable LOAD DATA LOCAL INFILE.",
     &opt_local_infile, &opt_local_infile, nullptr, GET_BOOL, OPT_ARG, 0, 0, 0,
     nullptr, 0, nullptr},
    {"no-beep", 'b', "Turn off beep on error.", &opt_nobeep, &opt_nobeep,
     nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"host", 'h', "Connect to host.", &current_host, &current_host, nullptr,
     GET_STR_ALLOC, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"html", 'H', "Produce HTML output.", &opt_html, &opt_html, nullptr,
     GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"xml", 'X', "Produce XML output.", &opt_xml, &opt_xml, nullptr, GET_BOOL,
     NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"line-numbers", OPT_LINE_NUMBERS, "Write line numbers for errors.",
     &line_numbers, &line_numbers, nullptr, GET_BOOL, NO_ARG, 1, 0, 0, nullptr,
     0, nullptr},
    {"skip-line-numbers", 'L', "Don't write line number for errors.", nullptr,
     nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"unbuffered", 'n', "Flush buffer after each query.", &unbuffered,
     &unbuffered, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"column-names", OPT_COLUMN_NAMES, "Write column names in results.",
     &column_names, &column_names, nullptr, GET_BOOL, NO_ARG, 1, 0, 0, nullptr,
     0, nullptr},
    {"skip-column-names", 'N', "Don't write column names in results.", nullptr,
     nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"sigint-ignore", OPT_SIGINT_IGNORE, "Ignore SIGINT (CTRL-C).",
     &opt_sigint_ignore, &opt_sigint_ignore, nullptr, GET_BOOL, NO_ARG, 0, 0, 0,
     nullptr, 0, nullptr},
    {"one-database", 'o',
     "Ignore statements except those that occur while the default "
     "database is the one named at the command line.",
     nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
#ifdef USE_POPEN
    {"pager", OPT_PAGER,
     "Pager to use to display results. If you don't supply an option, the "
     "default pager is taken from your ENV variable PAGER. Valid pagers are "
     "less, more, cat [> filename], etc. See interactive help (\\h) also. "
     "This option does not work in batch mode. Disable with --disable-pager. "
     "This option is disabled by default.",
     nullptr, nullptr, nullptr, GET_STR, OPT_ARG, 0, 0, 0, nullptr, 0, nullptr},
#endif
    {"password", 'p',
     "Password to use when connecting to server. If password is not given it's "
     "asked from the tty.",
     nullptr, nullptr, nullptr, GET_PASSWORD, OPT_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
#ifdef _WIN32
    {"pipe", 'W', "Use named pipes to connect to server.", 0, 0, 0, GET_NO_ARG,
     NO_ARG, 0, 0, 0, 0, 0, 0},
#endif
    {"port", 'P',
     "Port number to use for connection or 0 for default to, in "
     "order of preference, my.cnf, $MYSQL_TCP_PORT, "
#if MYSQL_PORT_DEFAULT == 0
     "/etc/services, "
#endif
     "built-in default (" STRINGIFY_ARG(MYSQL_PORT) ").",
     &opt_mysql_port, &opt_mysql_port, nullptr, GET_UINT, REQUIRED_ARG, 0, 0, 0,
     nullptr, 0, nullptr},
    {"prompt", OPT_PROMPT, "Set the mysql prompt to this value.",
     &current_prompt, &current_prompt, nullptr, GET_STR_ALLOC, REQUIRED_ARG, 0,
     0, 0, nullptr, 0, nullptr},
    {"protocol", OPT_MYSQL_PROTOCOL,
     "The protocol to use for connection (tcp, socket, pipe, memory).", nullptr,
     nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"quick", 'q',
     "Don't cache result, print it row by row. This may slow down the server "
     "if the output is suspended. Doesn't use history file.",
     &quick, &quick, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"raw", 'r', "Write fields without conversion. Used with --batch.",
     &opt_raw_data, &opt_raw_data, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr,
     0, nullptr},
    {"reconnect", OPT_RECONNECT,
     "Reconnect if the connection is lost. Disable "
     "with --disable-reconnect. This option is enabled by default.",
     &opt_reconnect, &opt_reconnect, nullptr, GET_BOOL, NO_ARG, 1, 0, 0,
     nullptr, 0, nullptr},
    {"silent", 's',
     "Be more silent. Print results with a tab as separator, "
     "each row on new line.",
     nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
#if defined(_WIN32)
    {"shared-memory-base-name", OPT_SHARED_MEMORY_BASE_NAME,
     "Base name of shared memory.", &shared_memory_base_name,
     &shared_memory_base_name, 0, GET_STR_ALLOC, REQUIRED_ARG, 0, 0, 0, 0, 0,
     0},
#endif
    {"socket", 'S', "The socket file to use for connection.",
     &opt_mysql_unix_port, &opt_mysql_unix_port, nullptr, GET_STR_ALLOC,
     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},
#include "caching_sha2_passwordopt-longopts.h"
#include "sslopt-longopts.h"

    {"table", 't', "Output in table format.", &output_tables, &output_tables,
     nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"tee", OPT_TEE,
     "Append everything into outfile. See interactive help (\\h) also. "
     "Does not work in batch mode. Disable with --disable-tee. "
     "This option is disabled by default.",
     nullptr, nullptr, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"user", 'u', "User for login if not current user.", &current_user,
     &current_user, nullptr, GET_STR_ALLOC, REQUIRED_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"safe-updates", 'U', "Only allow UPDATE and DELETE that uses keys.",
     &safe_updates, &safe_updates, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr,
     0, nullptr},
    {"i-am-a-dummy", 'U', "Synonym for option --safe-updates, -U.",
     &safe_updates, &safe_updates, nullptr, GET_BOOL, NO_ARG, 0, 0, 0, nullptr,
     0, nullptr},
    {"verbose", 'v', "Write more. (-v -v -v gives the table output format).",
     nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"version", 'V', "Output version information and exit.", nullptr, nullptr,
     nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"wait", 'w', "Wait and retry if connection is down.", nullptr, nullptr,
     nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"connect_timeout", OPT_CONNECT_TIMEOUT,
     "Number of seconds before connection timeout.", &opt_connect_timeout,
     &opt_connect_timeout, nullptr, GET_ULONG, REQUIRED_ARG, 0, 0, 3600 * 12,
     nullptr, 0, nullptr},
    {"max_allowed_packet", OPT_MAX_ALLOWED_PACKET,
     "The maximum packet length to send to or receive from server.",
     &opt_max_allowed_packet, &opt_max_allowed_packet, nullptr, GET_ULONG,
     REQUIRED_ARG, 16 * 1024L * 1024L, 4096,
     (longlong)2 * 1024L * 1024L * 1024L, nullptr, 1024, nullptr},
    {"net_buffer_length", OPT_NET_BUFFER_LENGTH,
     "The buffer size for TCP/IP and socket communication.",
     &opt_net_buffer_length, &opt_net_buffer_length, nullptr, GET_ULONG,
     REQUIRED_ARG, 16384, 1024, 512 * 1024 * 1024L, nullptr, 1024, nullptr},
    {"select_limit", OPT_SELECT_LIMIT,
     "Automatic limit for SELECT when using --safe-updates.", &select_limit,
     &select_limit, nullptr, GET_ULONG, REQUIRED_ARG, 1000L, 1, ULONG_MAX,
     nullptr, 1, nullptr},
    {"max_join_size", OPT_MAX_JOIN_SIZE,
     "Automatic limit for rows in a join when using --safe-updates.",
     &max_join_size, &max_join_size, nullptr, GET_ULONG, REQUIRED_ARG, 1000000L,
     1, ULONG_MAX, nullptr, 1, nullptr},
    {"show-warnings", OPT_SHOW_WARNINGS, "Show warnings after every statement.",
     &show_warnings, &show_warnings, nullptr, GET_BOOL, NO_ARG, 0, 0, 0,
     nullptr, 0, nullptr},
    {"syslog", 'j',
     "Log filtered interactive commands to syslog. Filtering of "
     "commands depends on the patterns supplied via histignore option besides "
     "the default patterns.",
     nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"plugin_dir", OPT_PLUGIN_DIR, "Directory for client-side plugins.",
     &opt_plugin_dir, &opt_plugin_dir, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0,
     nullptr, 0, nullptr},
    {"default_auth", OPT_DEFAULT_AUTH,
     "Default authentication client-side plugin to use.", &opt_default_auth,
     &opt_default_auth, nullptr, GET_STR, REQUIRED_ARG, 0, 0, 0, nullptr, 0,
     nullptr},
    {"binary-mode", OPT_BINARY_MODE,
     "By default, ASCII '\\0' is disallowed and '\\r\\n' is translated to "
     "'\\n'. "
     "This switch turns off both features, and also turns off parsing of all "
     "client"
     "commands except \\C and DELIMITER, in non-interactive mode (for input "
     "piped to mysql or loaded using the 'source' command). This is necessary "
     "when processing output from mysqlbinlog that may contain blobs.",
     &opt_binary_mode, &opt_binary_mode, nullptr, GET_BOOL, NO_ARG, 0, 0, 0,
     nullptr, 0, nullptr},
    {"connect-expired-password", 0,
     "Notify the server that this client is prepared to handle expired "
     "password sandbox mode.",
     &opt_connect_expired_password, &opt_connect_expired_password, nullptr,
     GET_BOOL, NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
#ifndef DBUG_OFF
    {"build-completion-hash", 0,
     "Build completion hash even when it is in batch mode. It is used for "
     "test purpose, so it is just built when DEBUG is on.",
     &opt_build_completion_hash, &opt_build_completion_hash, nullptr, GET_BOOL,
     NO_ARG, 0, 0, 0, nullptr, 0, nullptr},
#endif
#ifdef HAVE_SETNS
    {"network-namespace", 0,
     "Network namespace to use for connection via tcp with a server.",
     &opt_network_namespace, &opt_network_namespace, nullptr, GET_STR,
     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},
#endif
    {"compression-algorithms", 0,
     "Use compression algorithm in server/client protocol. Valid values "
     "are any combination of 'zstd','zlib','uncompressed'.",
     &opt_compress_algorithm, &opt_compress_algorithm, nullptr, GET_STR,
     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},
    {"zstd-compression-level", 0,
     "Use this compression level in the client/server protocol, in case "
     "--compression-algorithms=zstd. Valid range is between 1 and 22, "
     "inclusive. Default is 3.",
     &opt_zstd_compress_level, &opt_zstd_compress_level, nullptr, GET_UINT,
     REQUIRED_ARG, 3, 1, 22, nullptr, 0, nullptr},
    {"load_data_local_dir", OPT_LOAD_DATA_LOCAL_DIR,
     "Directory path safe for LOAD DATA LOCAL INFILE to read from.",
     &opt_load_data_local_dir, &opt_load_data_local_dir, nullptr, GET_STR,
     REQUIRED_ARG, 0, 0, 0, nullptr, 0, nullptr},

    {nullptr, 0, nullptr, nullptr, nullptr, nullptr, GET_NO_ARG, NO_ARG, 0, 0,
     0, nullptr, 0, nullptr}};

static void usage(int version) {
  print_version();

  if (version) return;
  puts(ORACLE_WELCOME_COPYRIGHT_NOTICE("2000"));
  printf("Usage: %s [OPTIONS] [database]\n", my_progname);
  my_print_help(my_long_options);
  print_defaults("my", load_default_groups);
  my_print_variables(my_long_options);
}

bool get_one_option(int optid,
                    const struct my_option *opt MY_ATTRIBUTE((unused)),
                    char *argument) {
  switch (optid) {
    case OPT_CHARSETS_DIR:
      strmake(mysql_charsets_dir, argument, sizeof(mysql_charsets_dir) - 1);
      charsets_dir = mysql_charsets_dir;
      break;
    case OPT_DELIMITER:
      if (argument == disabled_my_option) {
        my_stpcpy(delimiter, DEFAULT_DELIMITER);
      } else {
        /* Check that delimiter does not contain a backslash */
        if (!strstr(argument, "\\")) {
          strmake(delimiter, argument, sizeof(delimiter) - 1);
        } else {
          put_info("DELIMITER cannot contain a backslash character",
                   INFO_ERROR);
          return false;
        }
      }
      delimiter_length = (uint)strlen(delimiter);
      delimiter_str = delimiter;
      break;
    case OPT_LOCAL_INFILE:
      using_opt_local_infile = true;
      break;
    case OPT_ENABLE_CLEARTEXT_PLUGIN:
      using_opt_enable_cleartext_plugin = true;
      break;
    case OPT_TEE:
      if (argument == disabled_my_option) {
        if (opt_outfile) end_tee();
      } else
        init_tee(argument);
      break;
    case OPT_PAGER:
      if (argument == disabled_my_option)
        opt_nopager = true;
      else {
        opt_nopager = false;
        if (argument && strlen(argument)) {
          default_pager_set = true;
          strmake(pager, argument, sizeof(pager) - 1);
          my_stpcpy(default_pager, pager);
        } else if (default_pager_set)
          my_stpcpy(pager, default_pager);
        else
          opt_nopager = true;
      }
      break;
    case OPT_MYSQL_PROTOCOL:
      opt_protocol =
          find_type_or_exit(argument, &sql_protocol_typelib, opt->name);
      break;
    case 'A':
      opt_rehash = false;
      break;
    case 'N':
      column_names = false;
      break;
    case 'e':
      status.batch = true;
      status.add_to_history = false;
      if (!status.line_buff)
        ignore_errors = false;  // do it for the first -e only
      if (!(status.line_buff =
                batch_readline_command(status.line_buff, argument)))
        return true;
      break;
    case 'j':
      if (my_openlog("MysqlClient", 0, LOG_USER)) {
        /* error */
        put_info(strerror(errno), INFO_ERROR, errno);
        return true;
      }
      opt_syslog = true;
      break;
    case 'o':
      if (argument == disabled_my_option)
        one_database = false;
      else
        one_database = skip_updates = true;
      break;
    case 'p':
      if (argument == disabled_my_option) {
        // Don't require password
        static char empty_password[] = {'\0'};
        DBUG_ASSERT(empty_password[0] ==
                    '\0');  // Check that it has not been overwritten
        argument = empty_password;
      }
      if (argument) {
        char *start = argument;
        my_free(opt_password);
        opt_password = my_strdup(PSI_NOT_INSTRUMENTED, argument, MYF(MY_FAE));
        while (*argument) *argument++ = 'x';  // Destroy argument
        if (*start) start[1] = 0;
        tty_password = false;
      } else
        tty_password = true;
      break;
    case '#':
      DBUG_PUSH(argument ? argument : default_dbug_option);
      debug_info_flag = true;
      break;
    case 's':
      if (argument == disabled_my_option)
        opt_silent = 0;
      else
        opt_silent++;
      break;
    case 'v':
      if (argument == disabled_my_option)
        verbose = 0;
      else
        verbose++;
      break;
    case 'B':
      status.batch = true;
      status.add_to_history = false;
      opt_silent = std::max(opt_silent, 1U);  // more silent
      break;
    case 'W':
#ifdef _WIN32
      opt_protocol = MYSQL_PROTOCOL_PIPE;
#endif
      break;
#include "sslopt-case.h"

    case 'V':
      usage(1);
      exit(0);
    case 'I':
    case '?':
      usage(0);
      exit(0);
    case OPT_MYSQL_BINARY_AS_HEX:
      opt_binhex = (argument != disabled_my_option);
      opt_binary_as_hex_set_explicitly = true;
      break;
  }
  return false;
}

static int get_options(int argc, char **argv) {
  char *tmp, *pagpoint;
  int ho_error;

  tmp = (char *)getenv("MYSQL_HOST");
  if (tmp) current_host = my_strdup(PSI_NOT_INSTRUMENTED, tmp, MYF(MY_WME));

  pagpoint = getenv("PAGER");
  if (!((char *)(pagpoint))) {
    my_stpcpy(pager, "stdout");
    opt_nopager = true;
  } else
    my_stpcpy(pager, pagpoint);
  my_stpcpy(default_pager, pager);

  if (mysql_get_option(nullptr, MYSQL_OPT_MAX_ALLOWED_PACKET,
                       &opt_max_allowed_packet) ||
      mysql_get_option(nullptr, MYSQL_OPT_NET_BUFFER_LENGTH,
                       &opt_max_allowed_packet)) {
    exit(1);
  }

  if ((ho_error =
           handle_options(&argc, &argv, my_long_options, get_one_option)))
    exit(ho_error);

  if (mysql_options(nullptr, MYSQL_OPT_MAX_ALLOWED_PACKET,
                    &opt_max_allowed_packet) ||
      mysql_options(nullptr, MYSQL_OPT_NET_BUFFER_LENGTH,
                    &opt_net_buffer_length)) {
    exit(1);
  }

  if (status.batch) /* disable pager and outfile in this case */
  {
    my_stpcpy(default_pager, "stdout");
    my_stpcpy(pager, "stdout");
    opt_nopager = true;
    default_pager_set = false;
    opt_outfile = false;
    opt_reconnect = false;
    connect_flag = 0; /* Not in interactive mode */
  }

  if (argc > 1) {
    usage(0);
    exit(1);
  }
  if (argc == 1) {
    skip_updates = false;
    my_free(current_db);
    current_db = my_strdup(PSI_NOT_INSTRUMENTED, *argv, MYF(MY_WME));
  }
  if (tty_password) opt_password = get_tty_password(NullS);
  if (debug_info_flag) my_end_arg = MY_CHECK_ERROR | MY_GIVE_INFO;
  if (debug_check_flag) my_end_arg = MY_CHECK_ERROR;

  if (ignore_spaces) connect_flag |= CLIENT_IGNORE_SPACE;

  return (0);
}

static int read_and_execute(bool interactive) {
#if defined(_WIN32)
  String tmpbuf;
  String buffer;
#endif

  /*
    line can be allocated by:
    - batch_readline. Use my_free()
    - my_win_console_readline. Do not free, see tmpbuf.
    - readline. Use free()
  */
  char *line = nullptr;
  char in_string = 0;
  ulong line_number = 0;
  bool ml_comment = false;
  COMMANDS *com;
  size_t line_length = 0;
  status.exit_status = 1;

  real_binary_mode = !interactive && opt_binary_mode;
  for (;;) {
    /* Reset as SIGINT has already got handled. */
    sigint_received = false;

    if (!interactive) {
      /*
        batch_readline can return 0 on EOF or error.
        In that case, we need to double check that we have a valid
        line before actually setting line_length to read_length.
        */
      line = batch_readline(status.line_buff, real_binary_mode);
      if (line) {
        line_length = status.line_buff->read_length;

        /*
          ASCII 0x00 is not allowed appearing in queries if it is not in binary
          mode.
        */
        if (!real_binary_mode && strlen(line) != line_length) {
          status.exit_status = 1;
          String msg;
          msg.append(
              "ASCII '\\0' appeared in the statement, but this is not "
              "allowed unless option --binary-mode is enabled and mysql is "
              "run in non-interactive mode. Set --binary-mode to 1 if ASCII "
              "'\\0' is expected. Query: '");
          msg.append(glob_buffer);
          msg.append(line);
          msg.append("'.");
          put_info(msg.c_ptr(), INFO_ERROR);
          break;
        }

        /*
          Skip UTF8 Byte Order Marker (BOM) 0xEFBBBF.
          Editors like "notepad" put this marker in
          the very beginning of a text file when
          you save the file using "Unicode UTF-8" format.
        */
        if (!line_number && (uchar)line[0] == 0xEF && (uchar)line[1] == 0xBB &&
            (uchar)line[2] == 0xBF) {
          line += 3;
          // decrease the line length accordingly to the 3 bytes chopped
          line_length -= 3;
        }
      }
      line_number++;
      if (!glob_buffer.length()) status.query_start_line = line_number;
    } else {
      const char *prompt =
          (ml_comment
               ? "   /*> "
               : glob_buffer.is_empty()
                     ? construct_prompt()
                     : !in_string
                           ? "    -> "
                           : in_string == '\''
                                 ? "    '> "
                                 : (in_string == '`' ? "    `> " : "    \"> "));
      if (opt_outfile && glob_buffer.is_empty()) fflush(OUTFILE);

#if defined(_WIN32)
      size_t nread;
      tee_fputs(prompt, stdout);
      if (!tmpbuf.is_alloced()) tmpbuf.alloc(65535);
      tmpbuf.length(0);
      buffer.length(0);
      line = my_win_console_readline(charset_info, (char *)tmpbuf.ptr(),
                                     tmpbuf.alloced_length(), &nread);
      if (line && (nread == 0)) {
        tee_puts("^C", stdout);
        reset_prompt(&in_string, &ml_comment);
        continue;
      } else if (*line == 0x1A) /* (Ctrl + Z) */
        break;
#else
      if (opt_outfile) fputs(prompt, OUTFILE);
      /*
        free the previous entered line.
      */
      if (line) free(line);
      line = readline(prompt);

      if (sigint_received) {
        sigint_received = false;
        tee_puts("^C", stdout);
        reset_prompt(&in_string, &ml_comment);
        continue;
      }
#endif /* defined(_WIN32) */
      /*
        When Ctrl+d or Ctrl+z is pressed, the line may be NULL on some OS
        which may cause coredump.
      */
      if (opt_outfile && line) fprintf(OUTFILE, "%s\n", line);

      line_length = line ? strlen(line) : 0;
    }
    // End of file or system error
    if (!line) {
      if (status.line_buff && status.line_buff->error)
        status.exit_status = 1;
      else
        status.exit_status = 0;
      break;
    }

    /*
      Check if line is a mysql command line
      (We want to allow help, print and clear anywhere at line start
    */
    if ((named_cmds || glob_buffer.is_empty()) && !ml_comment && !in_string &&
        (com = find_command(line))) {
      if ((*com->func)(&glob_buffer, line) > 0) {
        // lets log the exit/quit command.
        if (interactive && status.add_to_history && com->cmd_char == 'q')
          add_filtered_history(line);
        break;
      }
      if (glob_buffer.is_empty())  // If buffer was emptied
        in_string = 0;
      if (interactive && status.add_to_history) add_filtered_history(line);
      continue;
    }
    if (add_line(glob_buffer, line, line_length, &in_string, &ml_comment,
                 status.line_buff ? status.line_buff->truncated : false))
      break;
  }
  /* if in batch mode, send last query even if it doesn't end with \g or go */

  if (!interactive && !status.exit_status) {
    remove_cntrl(&glob_buffer);
    if (!glob_buffer.is_empty()) {
      status.exit_status = 1;
      if (com_go(&glob_buffer, line) <= 0) status.exit_status = 0;
    }
  }

#if defined(_WIN32)
  buffer.mem_free();
  tmpbuf.mem_free();
#else
  if (interactive)
    /*
      free the last entered line.
    */
    free(line);
#endif

  /*
    If the function is called by 'source' command, it will return to interactive
    mode, so real_binary_mode should be false. Otherwise, it will exit the
    program, it is safe to set real_binary_mode to false.
  */
  real_binary_mode = false;
  return status.exit_status;
}

static inline void reset_prompt(char *in_string, bool *ml_comment) {
  glob_buffer.length(0);
  *ml_comment = false;
  *in_string = 0;
}

/**
   It checks if the input is a short form command. It returns the command's
   pointer if a command is found, else return NULL. Note that if binary-mode
   is set, then only @\C is searched for.

   @param cmd_char    A character of one byte.

   @return
     the command's pointer or NULL.
*/
static COMMANDS *find_command(char cmd_char) {
  DBUG_TRACE;
  DBUG_PRINT("enter", ("cmd_char: %d", cmd_char));

  int index = -1;

  /*
    In binary-mode, we disallow all mysql commands except '\C'
    and DELIMITER.
  */
  if (real_binary_mode) {
    if (cmd_char == 'C') index = charset_index;
  } else
    index = get_command_index(cmd_char);

  if (index >= 0) {
    DBUG_PRINT("exit", ("found command: %s", commands[index].name));
    return &commands[index];
  } else
    return (COMMANDS *)nullptr;
}

/**
   It checks if the input is a long form command. It returns the command's
   pointer if a command is found, else return NULL. Note that if binary-mode
   is set, then only DELIMITER is searched for.

   @param name    A string.
   @return
     the command's pointer or NULL.
*/
static COMMANDS *find_command(char *name) {
  uint len;
  char *end;
  DBUG_TRACE;
